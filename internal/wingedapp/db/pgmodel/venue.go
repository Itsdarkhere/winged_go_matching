// Code generated by SQLBoiler 4.19.5 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package pgmodel

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/sqlboiler/v4/types"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// Venue is an object representing the database table.
type Venue struct {
	ID               string            `boil:"id" json:"id" toml:"id" yaml:"id"`
	ExternalProvider string            `boil:"external_provider" json:"external_provider" toml:"external_provider" yaml:"external_provider"`
	ExternalID       string            `boil:"external_id" json:"external_id" toml:"external_id" yaml:"external_id"`
	Name             string            `boil:"name" json:"name" toml:"name" yaml:"name"`
	DisplayName      null.String       `boil:"display_name" json:"display_name,omitempty" toml:"display_name" yaml:"display_name,omitempty"`
	Address          null.String       `boil:"address" json:"address,omitempty" toml:"address" yaml:"address,omitempty"`
	Latitude         types.NullDecimal `boil:"latitude" json:"latitude,omitempty" toml:"latitude" yaml:"latitude,omitempty"`
	Longitude        types.NullDecimal `boil:"longitude" json:"longitude,omitempty" toml:"longitude" yaml:"longitude,omitempty"`
	VenueData        null.JSON         `boil:"venue_data" json:"venue_data,omitempty" toml:"venue_data" yaml:"venue_data,omitempty"`
	DietaryTags      types.StringArray `boil:"dietary_tags" json:"dietary_tags,omitempty" toml:"dietary_tags" yaml:"dietary_tags,omitempty"`
	DateTypeFit      types.StringArray `boil:"date_type_fit" json:"date_type_fit,omitempty" toml:"date_type_fit" yaml:"date_type_fit,omitempty"`
	Rating           types.NullDecimal `boil:"rating" json:"rating,omitempty" toml:"rating" yaml:"rating,omitempty"`
	PriceLevel       null.Int          `boil:"price_level" json:"price_level,omitempty" toml:"price_level" yaml:"price_level,omitempty"`
	UserRatingCount  null.Int          `boil:"user_rating_count" json:"user_rating_count,omitempty" toml:"user_rating_count" yaml:"user_rating_count,omitempty"`
	GoogleMapsURL    null.String       `boil:"google_maps_url" json:"google_maps_url,omitempty" toml:"google_maps_url" yaml:"google_maps_url,omitempty"`
	WebsiteURL       null.String       `boil:"website_url" json:"website_url,omitempty" toml:"website_url" yaml:"website_url,omitempty"`
	OpenNow          null.Bool         `boil:"open_now" json:"open_now,omitempty" toml:"open_now" yaml:"open_now,omitempty"`
	SortOrder        null.Int          `boil:"sort_order" json:"sort_order,omitempty" toml:"sort_order" yaml:"sort_order,omitempty"`
	BucketForVenue   null.String       `boil:"bucket_for_venue" json:"bucket_for_venue,omitempty" toml:"bucket_for_venue" yaml:"bucket_for_venue,omitempty"`
	SubtypeForVenue  null.String       `boil:"subtype_for_venue" json:"subtype_for_venue,omitempty" toml:"subtype_for_venue" yaml:"subtype_for_venue,omitempty"`
	PrimaryType      null.String       `boil:"primary_type" json:"primary_type,omitempty" toml:"primary_type" yaml:"primary_type,omitempty"`
	IsChain          null.Bool         `boil:"is_chain" json:"is_chain,omitempty" toml:"is_chain" yaml:"is_chain,omitempty"`
	NoiseLevel       null.String       `boil:"noise_level" json:"noise_level,omitempty" toml:"noise_level" yaml:"noise_level,omitempty"`
	ServesBreakfast  null.Bool         `boil:"serves_breakfast" json:"serves_breakfast,omitempty" toml:"serves_breakfast" yaml:"serves_breakfast,omitempty"`
	ServesBrunch     null.Bool         `boil:"serves_brunch" json:"serves_brunch,omitempty" toml:"serves_brunch" yaml:"serves_brunch,omitempty"`
	ServesLunch      null.Bool         `boil:"serves_lunch" json:"serves_lunch,omitempty" toml:"serves_lunch" yaml:"serves_lunch,omitempty"`
	ServesDinner     null.Bool         `boil:"serves_dinner" json:"serves_dinner,omitempty" toml:"serves_dinner" yaml:"serves_dinner,omitempty"`
	ServesBeer       null.Bool         `boil:"serves_beer" json:"serves_beer,omitempty" toml:"serves_beer" yaml:"serves_beer,omitempty"`
	ServesWine       null.Bool         `boil:"serves_wine" json:"serves_wine,omitempty" toml:"serves_wine" yaml:"serves_wine,omitempty"`
	ServesCocktails  null.Bool         `boil:"serves_cocktails" json:"serves_cocktails,omitempty" toml:"serves_cocktails" yaml:"serves_cocktails,omitempty"`
	ServesCoffee     null.Bool         `boil:"serves_coffee" json:"serves_coffee,omitempty" toml:"serves_coffee" yaml:"serves_coffee,omitempty"`
	OverviewText     null.String       `boil:"overview_text" json:"overview_text,omitempty" toml:"overview_text" yaml:"overview_text,omitempty"`
	DescriptionText  null.String       `boil:"description_text" json:"description_text,omitempty" toml:"description_text" yaml:"description_text,omitempty"`
	ReviewSummary    null.String       `boil:"review_summary" json:"review_summary,omitempty" toml:"review_summary" yaml:"review_summary,omitempty"`
	SampleReviews    types.StringArray `boil:"sample_reviews" json:"sample_reviews,omitempty" toml:"sample_reviews" yaml:"sample_reviews,omitempty"`
	CachedAt         time.Time         `boil:"cached_at" json:"cached_at" toml:"cached_at" yaml:"cached_at"`
	RefreshAfter     null.Time         `boil:"refresh_after" json:"refresh_after,omitempty" toml:"refresh_after" yaml:"refresh_after,omitempty"`

	R *venueR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L venueL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var VenueColumns = struct {
	ID               string
	ExternalProvider string
	ExternalID       string
	Name             string
	DisplayName      string
	Address          string
	Latitude         string
	Longitude        string
	VenueData        string
	DietaryTags      string
	DateTypeFit      string
	Rating           string
	PriceLevel       string
	UserRatingCount  string
	GoogleMapsURL    string
	WebsiteURL       string
	OpenNow          string
	SortOrder        string
	BucketForVenue   string
	SubtypeForVenue  string
	PrimaryType      string
	IsChain          string
	NoiseLevel       string
	ServesBreakfast  string
	ServesBrunch     string
	ServesLunch      string
	ServesDinner     string
	ServesBeer       string
	ServesWine       string
	ServesCocktails  string
	ServesCoffee     string
	OverviewText     string
	DescriptionText  string
	ReviewSummary    string
	SampleReviews    string
	CachedAt         string
	RefreshAfter     string
}{
	ID:               "id",
	ExternalProvider: "external_provider",
	ExternalID:       "external_id",
	Name:             "name",
	DisplayName:      "display_name",
	Address:          "address",
	Latitude:         "latitude",
	Longitude:        "longitude",
	VenueData:        "venue_data",
	DietaryTags:      "dietary_tags",
	DateTypeFit:      "date_type_fit",
	Rating:           "rating",
	PriceLevel:       "price_level",
	UserRatingCount:  "user_rating_count",
	GoogleMapsURL:    "google_maps_url",
	WebsiteURL:       "website_url",
	OpenNow:          "open_now",
	SortOrder:        "sort_order",
	BucketForVenue:   "bucket_for_venue",
	SubtypeForVenue:  "subtype_for_venue",
	PrimaryType:      "primary_type",
	IsChain:          "is_chain",
	NoiseLevel:       "noise_level",
	ServesBreakfast:  "serves_breakfast",
	ServesBrunch:     "serves_brunch",
	ServesLunch:      "serves_lunch",
	ServesDinner:     "serves_dinner",
	ServesBeer:       "serves_beer",
	ServesWine:       "serves_wine",
	ServesCocktails:  "serves_cocktails",
	ServesCoffee:     "serves_coffee",
	OverviewText:     "overview_text",
	DescriptionText:  "description_text",
	ReviewSummary:    "review_summary",
	SampleReviews:    "sample_reviews",
	CachedAt:         "cached_at",
	RefreshAfter:     "refresh_after",
}

var VenueTableColumns = struct {
	ID               string
	ExternalProvider string
	ExternalID       string
	Name             string
	DisplayName      string
	Address          string
	Latitude         string
	Longitude        string
	VenueData        string
	DietaryTags      string
	DateTypeFit      string
	Rating           string
	PriceLevel       string
	UserRatingCount  string
	GoogleMapsURL    string
	WebsiteURL       string
	OpenNow          string
	SortOrder        string
	BucketForVenue   string
	SubtypeForVenue  string
	PrimaryType      string
	IsChain          string
	NoiseLevel       string
	ServesBreakfast  string
	ServesBrunch     string
	ServesLunch      string
	ServesDinner     string
	ServesBeer       string
	ServesWine       string
	ServesCocktails  string
	ServesCoffee     string
	OverviewText     string
	DescriptionText  string
	ReviewSummary    string
	SampleReviews    string
	CachedAt         string
	RefreshAfter     string
}{
	ID:               "venue.id",
	ExternalProvider: "venue.external_provider",
	ExternalID:       "venue.external_id",
	Name:             "venue.name",
	DisplayName:      "venue.display_name",
	Address:          "venue.address",
	Latitude:         "venue.latitude",
	Longitude:        "venue.longitude",
	VenueData:        "venue.venue_data",
	DietaryTags:      "venue.dietary_tags",
	DateTypeFit:      "venue.date_type_fit",
	Rating:           "venue.rating",
	PriceLevel:       "venue.price_level",
	UserRatingCount:  "venue.user_rating_count",
	GoogleMapsURL:    "venue.google_maps_url",
	WebsiteURL:       "venue.website_url",
	OpenNow:          "venue.open_now",
	SortOrder:        "venue.sort_order",
	BucketForVenue:   "venue.bucket_for_venue",
	SubtypeForVenue:  "venue.subtype_for_venue",
	PrimaryType:      "venue.primary_type",
	IsChain:          "venue.is_chain",
	NoiseLevel:       "venue.noise_level",
	ServesBreakfast:  "venue.serves_breakfast",
	ServesBrunch:     "venue.serves_brunch",
	ServesLunch:      "venue.serves_lunch",
	ServesDinner:     "venue.serves_dinner",
	ServesBeer:       "venue.serves_beer",
	ServesWine:       "venue.serves_wine",
	ServesCocktails:  "venue.serves_cocktails",
	ServesCoffee:     "venue.serves_coffee",
	OverviewText:     "venue.overview_text",
	DescriptionText:  "venue.description_text",
	ReviewSummary:    "venue.review_summary",
	SampleReviews:    "venue.sample_reviews",
	CachedAt:         "venue.cached_at",
	RefreshAfter:     "venue.refresh_after",
}

// Generated where

type whereHelpertypes_NullDecimal struct{ field string }

func (w whereHelpertypes_NullDecimal) EQ(x types.NullDecimal) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpertypes_NullDecimal) NEQ(x types.NullDecimal) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpertypes_NullDecimal) LT(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_NullDecimal) LTE(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_NullDecimal) GT(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_NullDecimal) GTE(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpertypes_NullDecimal) IsNull() qm.QueryMod { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpertypes_NullDecimal) IsNotNull() qm.QueryMod {
	return qmhelper.WhereIsNotNull(w.field)
}

func (w whereHelpertypes_StringArray) IsNull() qm.QueryMod { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpertypes_StringArray) IsNotNull() qm.QueryMod {
	return qmhelper.WhereIsNotNull(w.field)
}

var VenueWhere = struct {
	ID               whereHelperstring
	ExternalProvider whereHelperstring
	ExternalID       whereHelperstring
	Name             whereHelperstring
	DisplayName      whereHelpernull_String
	Address          whereHelpernull_String
	Latitude         whereHelpertypes_NullDecimal
	Longitude        whereHelpertypes_NullDecimal
	VenueData        whereHelpernull_JSON
	DietaryTags      whereHelpertypes_StringArray
	DateTypeFit      whereHelpertypes_StringArray
	Rating           whereHelpertypes_NullDecimal
	PriceLevel       whereHelpernull_Int
	UserRatingCount  whereHelpernull_Int
	GoogleMapsURL    whereHelpernull_String
	WebsiteURL       whereHelpernull_String
	OpenNow          whereHelpernull_Bool
	SortOrder        whereHelpernull_Int
	BucketForVenue   whereHelpernull_String
	SubtypeForVenue  whereHelpernull_String
	PrimaryType      whereHelpernull_String
	IsChain          whereHelpernull_Bool
	NoiseLevel       whereHelpernull_String
	ServesBreakfast  whereHelpernull_Bool
	ServesBrunch     whereHelpernull_Bool
	ServesLunch      whereHelpernull_Bool
	ServesDinner     whereHelpernull_Bool
	ServesBeer       whereHelpernull_Bool
	ServesWine       whereHelpernull_Bool
	ServesCocktails  whereHelpernull_Bool
	ServesCoffee     whereHelpernull_Bool
	OverviewText     whereHelpernull_String
	DescriptionText  whereHelpernull_String
	ReviewSummary    whereHelpernull_String
	SampleReviews    whereHelpertypes_StringArray
	CachedAt         whereHelpertime_Time
	RefreshAfter     whereHelpernull_Time
}{
	ID:               whereHelperstring{field: "\"venue\".\"id\""},
	ExternalProvider: whereHelperstring{field: "\"venue\".\"external_provider\""},
	ExternalID:       whereHelperstring{field: "\"venue\".\"external_id\""},
	Name:             whereHelperstring{field: "\"venue\".\"name\""},
	DisplayName:      whereHelpernull_String{field: "\"venue\".\"display_name\""},
	Address:          whereHelpernull_String{field: "\"venue\".\"address\""},
	Latitude:         whereHelpertypes_NullDecimal{field: "\"venue\".\"latitude\""},
	Longitude:        whereHelpertypes_NullDecimal{field: "\"venue\".\"longitude\""},
	VenueData:        whereHelpernull_JSON{field: "\"venue\".\"venue_data\""},
	DietaryTags:      whereHelpertypes_StringArray{field: "\"venue\".\"dietary_tags\""},
	DateTypeFit:      whereHelpertypes_StringArray{field: "\"venue\".\"date_type_fit\""},
	Rating:           whereHelpertypes_NullDecimal{field: "\"venue\".\"rating\""},
	PriceLevel:       whereHelpernull_Int{field: "\"venue\".\"price_level\""},
	UserRatingCount:  whereHelpernull_Int{field: "\"venue\".\"user_rating_count\""},
	GoogleMapsURL:    whereHelpernull_String{field: "\"venue\".\"google_maps_url\""},
	WebsiteURL:       whereHelpernull_String{field: "\"venue\".\"website_url\""},
	OpenNow:          whereHelpernull_Bool{field: "\"venue\".\"open_now\""},
	SortOrder:        whereHelpernull_Int{field: "\"venue\".\"sort_order\""},
	BucketForVenue:   whereHelpernull_String{field: "\"venue\".\"bucket_for_venue\""},
	SubtypeForVenue:  whereHelpernull_String{field: "\"venue\".\"subtype_for_venue\""},
	PrimaryType:      whereHelpernull_String{field: "\"venue\".\"primary_type\""},
	IsChain:          whereHelpernull_Bool{field: "\"venue\".\"is_chain\""},
	NoiseLevel:       whereHelpernull_String{field: "\"venue\".\"noise_level\""},
	ServesBreakfast:  whereHelpernull_Bool{field: "\"venue\".\"serves_breakfast\""},
	ServesBrunch:     whereHelpernull_Bool{field: "\"venue\".\"serves_brunch\""},
	ServesLunch:      whereHelpernull_Bool{field: "\"venue\".\"serves_lunch\""},
	ServesDinner:     whereHelpernull_Bool{field: "\"venue\".\"serves_dinner\""},
	ServesBeer:       whereHelpernull_Bool{field: "\"venue\".\"serves_beer\""},
	ServesWine:       whereHelpernull_Bool{field: "\"venue\".\"serves_wine\""},
	ServesCocktails:  whereHelpernull_Bool{field: "\"venue\".\"serves_cocktails\""},
	ServesCoffee:     whereHelpernull_Bool{field: "\"venue\".\"serves_coffee\""},
	OverviewText:     whereHelpernull_String{field: "\"venue\".\"overview_text\""},
	DescriptionText:  whereHelpernull_String{field: "\"venue\".\"description_text\""},
	ReviewSummary:    whereHelpernull_String{field: "\"venue\".\"review_summary\""},
	SampleReviews:    whereHelpertypes_StringArray{field: "\"venue\".\"sample_reviews\""},
	CachedAt:         whereHelpertime_Time{field: "\"venue\".\"cached_at\""},
	RefreshAfter:     whereHelpernull_Time{field: "\"venue\".\"refresh_after\""},
}

// VenueRels is where relationship names are stored.
var VenueRels = struct {
	VenueRefDateInstances            string
	VenueRefVenueRankingCaches       string
	ResolvedVenueRefVenueSuggestions string
}{
	VenueRefDateInstances:            "VenueRefDateInstances",
	VenueRefVenueRankingCaches:       "VenueRefVenueRankingCaches",
	ResolvedVenueRefVenueSuggestions: "ResolvedVenueRefVenueSuggestions",
}

// venueR is where relationships are stored.
type venueR struct {
	VenueRefDateInstances            DateInstanceSlice      `boil:"VenueRefDateInstances" json:"VenueRefDateInstances" toml:"VenueRefDateInstances" yaml:"VenueRefDateInstances"`
	VenueRefVenueRankingCaches       VenueRankingCacheSlice `boil:"VenueRefVenueRankingCaches" json:"VenueRefVenueRankingCaches" toml:"VenueRefVenueRankingCaches" yaml:"VenueRefVenueRankingCaches"`
	ResolvedVenueRefVenueSuggestions VenueSuggestionSlice   `boil:"ResolvedVenueRefVenueSuggestions" json:"ResolvedVenueRefVenueSuggestions" toml:"ResolvedVenueRefVenueSuggestions" yaml:"ResolvedVenueRefVenueSuggestions"`
}

// NewStruct creates a new relationship struct
func (*venueR) NewStruct() *venueR {
	return &venueR{}
}

func (o *Venue) GetVenueRefDateInstances() DateInstanceSlice {
	if o == nil {
		return nil
	}

	return o.R.GetVenueRefDateInstances()
}

func (r *venueR) GetVenueRefDateInstances() DateInstanceSlice {
	if r == nil {
		return nil
	}

	return r.VenueRefDateInstances
}

func (o *Venue) GetVenueRefVenueRankingCaches() VenueRankingCacheSlice {
	if o == nil {
		return nil
	}

	return o.R.GetVenueRefVenueRankingCaches()
}

func (r *venueR) GetVenueRefVenueRankingCaches() VenueRankingCacheSlice {
	if r == nil {
		return nil
	}

	return r.VenueRefVenueRankingCaches
}

func (o *Venue) GetResolvedVenueRefVenueSuggestions() VenueSuggestionSlice {
	if o == nil {
		return nil
	}

	return o.R.GetResolvedVenueRefVenueSuggestions()
}

func (r *venueR) GetResolvedVenueRefVenueSuggestions() VenueSuggestionSlice {
	if r == nil {
		return nil
	}

	return r.ResolvedVenueRefVenueSuggestions
}

// venueL is where Load methods for each relationship are stored.
type venueL struct{}

var (
	venueAllColumns            = []string{"id", "external_provider", "external_id", "name", "display_name", "address", "latitude", "longitude", "venue_data", "dietary_tags", "date_type_fit", "rating", "price_level", "user_rating_count", "google_maps_url", "website_url", "open_now", "sort_order", "bucket_for_venue", "subtype_for_venue", "primary_type", "is_chain", "noise_level", "serves_breakfast", "serves_brunch", "serves_lunch", "serves_dinner", "serves_beer", "serves_wine", "serves_cocktails", "serves_coffee", "overview_text", "description_text", "review_summary", "sample_reviews", "cached_at", "refresh_after"}
	venueColumnsWithoutDefault = []string{"external_provider", "external_id", "name"}
	venueColumnsWithDefault    = []string{"id", "display_name", "address", "latitude", "longitude", "venue_data", "dietary_tags", "date_type_fit", "rating", "price_level", "user_rating_count", "google_maps_url", "website_url", "open_now", "sort_order", "bucket_for_venue", "subtype_for_venue", "primary_type", "is_chain", "noise_level", "serves_breakfast", "serves_brunch", "serves_lunch", "serves_dinner", "serves_beer", "serves_wine", "serves_cocktails", "serves_coffee", "overview_text", "description_text", "review_summary", "sample_reviews", "cached_at", "refresh_after"}
	venuePrimaryKeyColumns     = []string{"id"}
	venueGeneratedColumns      = []string{}
)

type (
	// VenueSlice is an alias for a slice of pointers to Venue.
	// This should almost always be used instead of []Venue.
	VenueSlice []*Venue
	// VenueHook is the signature for custom Venue hook methods
	VenueHook func(context.Context, boil.ContextExecutor, *Venue) error

	venueQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	venueType                 = reflect.TypeOf(&Venue{})
	venueMapping              = queries.MakeStructMapping(venueType)
	venuePrimaryKeyMapping, _ = queries.BindMapping(venueType, venueMapping, venuePrimaryKeyColumns)
	venueInsertCacheMut       sync.RWMutex
	venueInsertCache          = make(map[string]insertCache)
	venueUpdateCacheMut       sync.RWMutex
	venueUpdateCache          = make(map[string]updateCache)
	venueUpsertCacheMut       sync.RWMutex
	venueUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var venueAfterSelectMu sync.Mutex
var venueAfterSelectHooks []VenueHook

var venueBeforeInsertMu sync.Mutex
var venueBeforeInsertHooks []VenueHook
var venueAfterInsertMu sync.Mutex
var venueAfterInsertHooks []VenueHook

var venueBeforeUpdateMu sync.Mutex
var venueBeforeUpdateHooks []VenueHook
var venueAfterUpdateMu sync.Mutex
var venueAfterUpdateHooks []VenueHook

var venueBeforeDeleteMu sync.Mutex
var venueBeforeDeleteHooks []VenueHook
var venueAfterDeleteMu sync.Mutex
var venueAfterDeleteHooks []VenueHook

var venueBeforeUpsertMu sync.Mutex
var venueBeforeUpsertHooks []VenueHook
var venueAfterUpsertMu sync.Mutex
var venueAfterUpsertHooks []VenueHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Venue) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range venueAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Venue) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range venueBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Venue) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range venueAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Venue) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range venueBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Venue) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range venueAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Venue) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range venueBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Venue) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range venueAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Venue) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range venueBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Venue) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range venueAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddVenueHook registers your hook function for all future operations.
func AddVenueHook(hookPoint boil.HookPoint, venueHook VenueHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		venueAfterSelectMu.Lock()
		venueAfterSelectHooks = append(venueAfterSelectHooks, venueHook)
		venueAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		venueBeforeInsertMu.Lock()
		venueBeforeInsertHooks = append(venueBeforeInsertHooks, venueHook)
		venueBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		venueAfterInsertMu.Lock()
		venueAfterInsertHooks = append(venueAfterInsertHooks, venueHook)
		venueAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		venueBeforeUpdateMu.Lock()
		venueBeforeUpdateHooks = append(venueBeforeUpdateHooks, venueHook)
		venueBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		venueAfterUpdateMu.Lock()
		venueAfterUpdateHooks = append(venueAfterUpdateHooks, venueHook)
		venueAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		venueBeforeDeleteMu.Lock()
		venueBeforeDeleteHooks = append(venueBeforeDeleteHooks, venueHook)
		venueBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		venueAfterDeleteMu.Lock()
		venueAfterDeleteHooks = append(venueAfterDeleteHooks, venueHook)
		venueAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		venueBeforeUpsertMu.Lock()
		venueBeforeUpsertHooks = append(venueBeforeUpsertHooks, venueHook)
		venueBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		venueAfterUpsertMu.Lock()
		venueAfterUpsertHooks = append(venueAfterUpsertHooks, venueHook)
		venueAfterUpsertMu.Unlock()
	}
}

// One returns a single venue record from the query.
func (q venueQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Venue, error) {
	o := &Venue{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "pgmodel: failed to execute a one query for venue")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Venue records from the query.
func (q venueQuery) All(ctx context.Context, exec boil.ContextExecutor) (VenueSlice, error) {
	var o []*Venue

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "pgmodel: failed to assign all query results to Venue slice")
	}

	if len(venueAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Venue records in the query.
func (q venueQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: failed to count venue rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q venueQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "pgmodel: failed to check if venue exists")
	}

	return count > 0, nil
}

// VenueRefDateInstances retrieves all the date_instance's DateInstances with an executor via venue_ref_id column.
func (o *Venue) VenueRefDateInstances(mods ...qm.QueryMod) dateInstanceQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"date_instance\".\"venue_ref_id\"=?", o.ID),
	)

	return DateInstances(queryMods...)
}

// VenueRefVenueRankingCaches retrieves all the venue_ranking_cache's VenueRankingCaches with an executor via venue_ref_id column.
func (o *Venue) VenueRefVenueRankingCaches(mods ...qm.QueryMod) venueRankingCacheQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"venue_ranking_cache\".\"venue_ref_id\"=?", o.ID),
	)

	return VenueRankingCaches(queryMods...)
}

// ResolvedVenueRefVenueSuggestions retrieves all the venue_suggestion's VenueSuggestions with an executor via resolved_venue_ref_id column.
func (o *Venue) ResolvedVenueRefVenueSuggestions(mods ...qm.QueryMod) venueSuggestionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"venue_suggestion\".\"resolved_venue_ref_id\"=?", o.ID),
	)

	return VenueSuggestions(queryMods...)
}

// LoadVenueRefDateInstances allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (venueL) LoadVenueRefDateInstances(ctx context.Context, e boil.ContextExecutor, singular bool, maybeVenue interface{}, mods queries.Applicator) error {
	var slice []*Venue
	var object *Venue

	if singular {
		var ok bool
		object, ok = maybeVenue.(*Venue)
		if !ok {
			object = new(Venue)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeVenue)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeVenue))
			}
		}
	} else {
		s, ok := maybeVenue.(*[]*Venue)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeVenue)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeVenue))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &venueR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &venueR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`date_instance`),
		qm.WhereIn(`date_instance.venue_ref_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load date_instance")
	}

	var resultSlice []*DateInstance
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice date_instance")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on date_instance")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for date_instance")
	}

	if len(dateInstanceAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.VenueRefDateInstances = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dateInstanceR{}
			}
			foreign.R.VenueRef = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.VenueRefID) {
				local.R.VenueRefDateInstances = append(local.R.VenueRefDateInstances, foreign)
				if foreign.R == nil {
					foreign.R = &dateInstanceR{}
				}
				foreign.R.VenueRef = local
				break
			}
		}
	}

	return nil
}

// LoadVenueRefVenueRankingCaches allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (venueL) LoadVenueRefVenueRankingCaches(ctx context.Context, e boil.ContextExecutor, singular bool, maybeVenue interface{}, mods queries.Applicator) error {
	var slice []*Venue
	var object *Venue

	if singular {
		var ok bool
		object, ok = maybeVenue.(*Venue)
		if !ok {
			object = new(Venue)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeVenue)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeVenue))
			}
		}
	} else {
		s, ok := maybeVenue.(*[]*Venue)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeVenue)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeVenue))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &venueR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &venueR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`venue_ranking_cache`),
		qm.WhereIn(`venue_ranking_cache.venue_ref_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load venue_ranking_cache")
	}

	var resultSlice []*VenueRankingCache
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice venue_ranking_cache")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on venue_ranking_cache")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for venue_ranking_cache")
	}

	if len(venueRankingCacheAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.VenueRefVenueRankingCaches = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &venueRankingCacheR{}
			}
			foreign.R.VenueRef = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.VenueRefID {
				local.R.VenueRefVenueRankingCaches = append(local.R.VenueRefVenueRankingCaches, foreign)
				if foreign.R == nil {
					foreign.R = &venueRankingCacheR{}
				}
				foreign.R.VenueRef = local
				break
			}
		}
	}

	return nil
}

// LoadResolvedVenueRefVenueSuggestions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (venueL) LoadResolvedVenueRefVenueSuggestions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeVenue interface{}, mods queries.Applicator) error {
	var slice []*Venue
	var object *Venue

	if singular {
		var ok bool
		object, ok = maybeVenue.(*Venue)
		if !ok {
			object = new(Venue)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeVenue)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeVenue))
			}
		}
	} else {
		s, ok := maybeVenue.(*[]*Venue)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeVenue)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeVenue))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &venueR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &venueR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`venue_suggestion`),
		qm.WhereIn(`venue_suggestion.resolved_venue_ref_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load venue_suggestion")
	}

	var resultSlice []*VenueSuggestion
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice venue_suggestion")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on venue_suggestion")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for venue_suggestion")
	}

	if len(venueSuggestionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ResolvedVenueRefVenueSuggestions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &venueSuggestionR{}
			}
			foreign.R.ResolvedVenueRef = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.ResolvedVenueRefID) {
				local.R.ResolvedVenueRefVenueSuggestions = append(local.R.ResolvedVenueRefVenueSuggestions, foreign)
				if foreign.R == nil {
					foreign.R = &venueSuggestionR{}
				}
				foreign.R.ResolvedVenueRef = local
				break
			}
		}
	}

	return nil
}

// AddVenueRefDateInstances adds the given related objects to the existing relationships
// of the venue, optionally inserting them as new records.
// Appends related to o.R.VenueRefDateInstances.
// Sets related.R.VenueRef appropriately.
func (o *Venue) AddVenueRefDateInstances(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DateInstance) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.VenueRefID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"date_instance\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"venue_ref_id"}),
				strmangle.WhereClause("\"", "\"", 2, dateInstancePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.VenueRefID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &venueR{
			VenueRefDateInstances: related,
		}
	} else {
		o.R.VenueRefDateInstances = append(o.R.VenueRefDateInstances, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dateInstanceR{
				VenueRef: o,
			}
		} else {
			rel.R.VenueRef = o
		}
	}
	return nil
}

// SetVenueRefDateInstances removes all previously related items of the
// venue replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.VenueRef's VenueRefDateInstances accordingly.
// Replaces o.R.VenueRefDateInstances with related.
// Sets related.R.VenueRef's VenueRefDateInstances accordingly.
func (o *Venue) SetVenueRefDateInstances(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DateInstance) error {
	query := "update \"date_instance\" set \"venue_ref_id\" = null where \"venue_ref_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.VenueRefDateInstances {
			queries.SetScanner(&rel.VenueRefID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.VenueRef = nil
		}
		o.R.VenueRefDateInstances = nil
	}

	return o.AddVenueRefDateInstances(ctx, exec, insert, related...)
}

// RemoveVenueRefDateInstances relationships from objects passed in.
// Removes related items from R.VenueRefDateInstances (uses pointer comparison, removal does not keep order)
// Sets related.R.VenueRef.
func (o *Venue) RemoveVenueRefDateInstances(ctx context.Context, exec boil.ContextExecutor, related ...*DateInstance) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.VenueRefID, nil)
		if rel.R != nil {
			rel.R.VenueRef = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("venue_ref_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.VenueRefDateInstances {
			if rel != ri {
				continue
			}

			ln := len(o.R.VenueRefDateInstances)
			if ln > 1 && i < ln-1 {
				o.R.VenueRefDateInstances[i] = o.R.VenueRefDateInstances[ln-1]
			}
			o.R.VenueRefDateInstances = o.R.VenueRefDateInstances[:ln-1]
			break
		}
	}

	return nil
}

// AddVenueRefVenueRankingCaches adds the given related objects to the existing relationships
// of the venue, optionally inserting them as new records.
// Appends related to o.R.VenueRefVenueRankingCaches.
// Sets related.R.VenueRef appropriately.
func (o *Venue) AddVenueRefVenueRankingCaches(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*VenueRankingCache) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.VenueRefID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"venue_ranking_cache\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"venue_ref_id"}),
				strmangle.WhereClause("\"", "\"", 2, venueRankingCachePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.VenueRefID = o.ID
		}
	}

	if o.R == nil {
		o.R = &venueR{
			VenueRefVenueRankingCaches: related,
		}
	} else {
		o.R.VenueRefVenueRankingCaches = append(o.R.VenueRefVenueRankingCaches, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &venueRankingCacheR{
				VenueRef: o,
			}
		} else {
			rel.R.VenueRef = o
		}
	}
	return nil
}

// AddResolvedVenueRefVenueSuggestions adds the given related objects to the existing relationships
// of the venue, optionally inserting them as new records.
// Appends related to o.R.ResolvedVenueRefVenueSuggestions.
// Sets related.R.ResolvedVenueRef appropriately.
func (o *Venue) AddResolvedVenueRefVenueSuggestions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*VenueSuggestion) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ResolvedVenueRefID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"venue_suggestion\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"resolved_venue_ref_id"}),
				strmangle.WhereClause("\"", "\"", 2, venueSuggestionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ResolvedVenueRefID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &venueR{
			ResolvedVenueRefVenueSuggestions: related,
		}
	} else {
		o.R.ResolvedVenueRefVenueSuggestions = append(o.R.ResolvedVenueRefVenueSuggestions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &venueSuggestionR{
				ResolvedVenueRef: o,
			}
		} else {
			rel.R.ResolvedVenueRef = o
		}
	}
	return nil
}

// SetResolvedVenueRefVenueSuggestions removes all previously related items of the
// venue replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.ResolvedVenueRef's ResolvedVenueRefVenueSuggestions accordingly.
// Replaces o.R.ResolvedVenueRefVenueSuggestions with related.
// Sets related.R.ResolvedVenueRef's ResolvedVenueRefVenueSuggestions accordingly.
func (o *Venue) SetResolvedVenueRefVenueSuggestions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*VenueSuggestion) error {
	query := "update \"venue_suggestion\" set \"resolved_venue_ref_id\" = null where \"resolved_venue_ref_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ResolvedVenueRefVenueSuggestions {
			queries.SetScanner(&rel.ResolvedVenueRefID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.ResolvedVenueRef = nil
		}
		o.R.ResolvedVenueRefVenueSuggestions = nil
	}

	return o.AddResolvedVenueRefVenueSuggestions(ctx, exec, insert, related...)
}

// RemoveResolvedVenueRefVenueSuggestions relationships from objects passed in.
// Removes related items from R.ResolvedVenueRefVenueSuggestions (uses pointer comparison, removal does not keep order)
// Sets related.R.ResolvedVenueRef.
func (o *Venue) RemoveResolvedVenueRefVenueSuggestions(ctx context.Context, exec boil.ContextExecutor, related ...*VenueSuggestion) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ResolvedVenueRefID, nil)
		if rel.R != nil {
			rel.R.ResolvedVenueRef = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("resolved_venue_ref_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ResolvedVenueRefVenueSuggestions {
			if rel != ri {
				continue
			}

			ln := len(o.R.ResolvedVenueRefVenueSuggestions)
			if ln > 1 && i < ln-1 {
				o.R.ResolvedVenueRefVenueSuggestions[i] = o.R.ResolvedVenueRefVenueSuggestions[ln-1]
			}
			o.R.ResolvedVenueRefVenueSuggestions = o.R.ResolvedVenueRefVenueSuggestions[:ln-1]
			break
		}
	}

	return nil
}

// Venues retrieves all the records using an executor.
func Venues(mods ...qm.QueryMod) venueQuery {
	mods = append(mods, qm.From("\"venue\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"venue\".*"})
	}

	return venueQuery{q}
}

// FindVenue retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindVenue(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*Venue, error) {
	venueObj := &Venue{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"venue\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, venueObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "pgmodel: unable to select from venue")
	}

	if err = venueObj.doAfterSelectHooks(ctx, exec); err != nil {
		return venueObj, err
	}

	return venueObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Venue) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("pgmodel: no venue provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(venueColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	venueInsertCacheMut.RLock()
	cache, cached := venueInsertCache[key]
	venueInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			venueAllColumns,
			venueColumnsWithDefault,
			venueColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(venueType, venueMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(venueType, venueMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"venue\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"venue\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "pgmodel: unable to insert into venue")
	}

	if !cached {
		venueInsertCacheMut.Lock()
		venueInsertCache[key] = cache
		venueInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Venue.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Venue) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	venueUpdateCacheMut.RLock()
	cache, cached := venueUpdateCache[key]
	venueUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			venueAllColumns,
			venuePrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("pgmodel: unable to update venue, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"venue\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, venuePrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(venueType, venueMapping, append(wl, venuePrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to update venue row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: failed to get rows affected by update for venue")
	}

	if !cached {
		venueUpdateCacheMut.Lock()
		venueUpdateCache[key] = cache
		venueUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q venueQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to update all for venue")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to retrieve rows affected for venue")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o VenueSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("pgmodel: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), venuePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"venue\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, venuePrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to update all in venue slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to retrieve rows affected all in update all venue")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Venue) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("pgmodel: no venue provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(venueColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	venueUpsertCacheMut.RLock()
	cache, cached := venueUpsertCache[key]
	venueUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			venueAllColumns,
			venueColumnsWithDefault,
			venueColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			venueAllColumns,
			venuePrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("pgmodel: unable to upsert venue, could not build update column list")
		}

		ret := strmangle.SetComplement(venueAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(venuePrimaryKeyColumns) == 0 {
				return errors.New("pgmodel: unable to upsert venue, could not build conflict column list")
			}

			conflict = make([]string, len(venuePrimaryKeyColumns))
			copy(conflict, venuePrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"venue\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(venueType, venueMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(venueType, venueMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "pgmodel: unable to upsert venue")
	}

	if !cached {
		venueUpsertCacheMut.Lock()
		venueUpsertCache[key] = cache
		venueUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Venue record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Venue) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("pgmodel: no Venue provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), venuePrimaryKeyMapping)
	sql := "DELETE FROM \"venue\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to delete from venue")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: failed to get rows affected by delete for venue")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q venueQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("pgmodel: no venueQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to delete all from venue")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: failed to get rows affected by deleteall for venue")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o VenueSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(venueBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), venuePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"venue\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, venuePrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to delete all from venue slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: failed to get rows affected by deleteall for venue")
	}

	if len(venueAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Venue) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindVenue(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *VenueSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := VenueSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), venuePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"venue\".* FROM \"venue\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, venuePrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "pgmodel: unable to reload all in VenueSlice")
	}

	*o = slice

	return nil
}

// VenueExists checks if the Venue row exists.
func VenueExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"venue\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "pgmodel: unable to check if venue exists")
	}

	return exists, nil
}

// Exists checks if the Venue row exists.
func (o *Venue) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return VenueExists(ctx, exec, o.ID)
}
