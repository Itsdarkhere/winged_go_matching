// Code generated by SQLBoiler 4.19.5 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package pgmodel

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// DateInstance is an object representing the database table.
type DateInstance struct {
	ID                   string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	MatchResultRefID     string      `boil:"match_result_ref_id" json:"match_result_ref_id" toml:"match_result_ref_id" yaml:"match_result_ref_id"`
	VenueRefID           null.String `boil:"venue_ref_id" json:"venue_ref_id,omitempty" toml:"venue_ref_id" yaml:"venue_ref_id,omitempty"`
	DateTypeCore         null.String `boil:"date_type_core" json:"date_type_core,omitempty" toml:"date_type_core" yaml:"date_type_core,omitempty"`
	Status               string      `boil:"status" json:"status" toml:"status" yaml:"status"`
	ScheduledTimeUtc     null.Time   `boil:"scheduled_time_utc" json:"scheduled_time_utc,omitempty" toml:"scheduled_time_utc" yaml:"scheduled_time_utc,omitempty"`
	DurationMinutes      null.Int    `boil:"duration_minutes" json:"duration_minutes,omitempty" toml:"duration_minutes" yaml:"duration_minutes,omitempty"`
	BookingStatus        null.String `boil:"booking_status" json:"booking_status,omitempty" toml:"booking_status" yaml:"booking_status,omitempty"`
	FeedbackStatusUserA  null.String `boil:"feedback_status_user_a" json:"feedback_status_user_a,omitempty" toml:"feedback_status_user_a" yaml:"feedback_status_user_a,omitempty"`
	DecisionUserA        null.String `boil:"decision_user_a" json:"decision_user_a,omitempty" toml:"decision_user_a" yaml:"decision_user_a,omitempty"`
	DidMeetUserA         null.String `boil:"did_meet_user_a" json:"did_meet_user_a,omitempty" toml:"did_meet_user_a" yaml:"did_meet_user_a,omitempty"`
	FeedbackTextUserA    null.String `boil:"feedback_text_user_a" json:"feedback_text_user_a,omitempty" toml:"feedback_text_user_a" yaml:"feedback_text_user_a,omitempty"`
	FeedbackStatusUserB  null.String `boil:"feedback_status_user_b" json:"feedback_status_user_b,omitempty" toml:"feedback_status_user_b" yaml:"feedback_status_user_b,omitempty"`
	DecisionUserB        null.String `boil:"decision_user_b" json:"decision_user_b,omitempty" toml:"decision_user_b" yaml:"decision_user_b,omitempty"`
	DidMeetUserB         null.String `boil:"did_meet_user_b" json:"did_meet_user_b,omitempty" toml:"did_meet_user_b" yaml:"did_meet_user_b,omitempty"`
	FeedbackTextUserB    null.String `boil:"feedback_text_user_b" json:"feedback_text_user_b,omitempty" toml:"feedback_text_user_b" yaml:"feedback_text_user_b,omitempty"`
	DecisionWindowEnd    time.Time   `boil:"decision_window_end" json:"decision_window_end" toml:"decision_window_end" yaml:"decision_window_end"`
	InitiatorConfirmedAt null.Time   `boil:"initiator_confirmed_at" json:"initiator_confirmed_at,omitempty" toml:"initiator_confirmed_at" yaml:"initiator_confirmed_at,omitempty"`
	ReceiverConfirmedAt  null.Time   `boil:"receiver_confirmed_at" json:"receiver_confirmed_at,omitempty" toml:"receiver_confirmed_at" yaml:"receiver_confirmed_at,omitempty"`
	BookingFailureReason null.String `boil:"booking_failure_reason" json:"booking_failure_reason,omitempty" toml:"booking_failure_reason" yaml:"booking_failure_reason,omitempty"`
	VenueProposalStatus  null.String `boil:"venue_proposal_status" json:"venue_proposal_status,omitempty" toml:"venue_proposal_status" yaml:"venue_proposal_status,omitempty"`
	AvailabilitySyncMode null.String `boil:"availability_sync_mode" json:"availability_sync_mode,omitempty" toml:"availability_sync_mode" yaml:"availability_sync_mode,omitempty"`
	CreatedAt            time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt            null.Time   `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`

	R *dateInstanceR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L dateInstanceL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DateInstanceColumns = struct {
	ID                   string
	MatchResultRefID     string
	VenueRefID           string
	DateTypeCore         string
	Status               string
	ScheduledTimeUtc     string
	DurationMinutes      string
	BookingStatus        string
	FeedbackStatusUserA  string
	DecisionUserA        string
	DidMeetUserA         string
	FeedbackTextUserA    string
	FeedbackStatusUserB  string
	DecisionUserB        string
	DidMeetUserB         string
	FeedbackTextUserB    string
	DecisionWindowEnd    string
	InitiatorConfirmedAt string
	ReceiverConfirmedAt  string
	BookingFailureReason string
	VenueProposalStatus  string
	AvailabilitySyncMode string
	CreatedAt            string
	UpdatedAt            string
}{
	ID:                   "id",
	MatchResultRefID:     "match_result_ref_id",
	VenueRefID:           "venue_ref_id",
	DateTypeCore:         "date_type_core",
	Status:               "status",
	ScheduledTimeUtc:     "scheduled_time_utc",
	DurationMinutes:      "duration_minutes",
	BookingStatus:        "booking_status",
	FeedbackStatusUserA:  "feedback_status_user_a",
	DecisionUserA:        "decision_user_a",
	DidMeetUserA:         "did_meet_user_a",
	FeedbackTextUserA:    "feedback_text_user_a",
	FeedbackStatusUserB:  "feedback_status_user_b",
	DecisionUserB:        "decision_user_b",
	DidMeetUserB:         "did_meet_user_b",
	FeedbackTextUserB:    "feedback_text_user_b",
	DecisionWindowEnd:    "decision_window_end",
	InitiatorConfirmedAt: "initiator_confirmed_at",
	ReceiverConfirmedAt:  "receiver_confirmed_at",
	BookingFailureReason: "booking_failure_reason",
	VenueProposalStatus:  "venue_proposal_status",
	AvailabilitySyncMode: "availability_sync_mode",
	CreatedAt:            "created_at",
	UpdatedAt:            "updated_at",
}

var DateInstanceTableColumns = struct {
	ID                   string
	MatchResultRefID     string
	VenueRefID           string
	DateTypeCore         string
	Status               string
	ScheduledTimeUtc     string
	DurationMinutes      string
	BookingStatus        string
	FeedbackStatusUserA  string
	DecisionUserA        string
	DidMeetUserA         string
	FeedbackTextUserA    string
	FeedbackStatusUserB  string
	DecisionUserB        string
	DidMeetUserB         string
	FeedbackTextUserB    string
	DecisionWindowEnd    string
	InitiatorConfirmedAt string
	ReceiverConfirmedAt  string
	BookingFailureReason string
	VenueProposalStatus  string
	AvailabilitySyncMode string
	CreatedAt            string
	UpdatedAt            string
}{
	ID:                   "date_instance.id",
	MatchResultRefID:     "date_instance.match_result_ref_id",
	VenueRefID:           "date_instance.venue_ref_id",
	DateTypeCore:         "date_instance.date_type_core",
	Status:               "date_instance.status",
	ScheduledTimeUtc:     "date_instance.scheduled_time_utc",
	DurationMinutes:      "date_instance.duration_minutes",
	BookingStatus:        "date_instance.booking_status",
	FeedbackStatusUserA:  "date_instance.feedback_status_user_a",
	DecisionUserA:        "date_instance.decision_user_a",
	DidMeetUserA:         "date_instance.did_meet_user_a",
	FeedbackTextUserA:    "date_instance.feedback_text_user_a",
	FeedbackStatusUserB:  "date_instance.feedback_status_user_b",
	DecisionUserB:        "date_instance.decision_user_b",
	DidMeetUserB:         "date_instance.did_meet_user_b",
	FeedbackTextUserB:    "date_instance.feedback_text_user_b",
	DecisionWindowEnd:    "date_instance.decision_window_end",
	InitiatorConfirmedAt: "date_instance.initiator_confirmed_at",
	ReceiverConfirmedAt:  "date_instance.receiver_confirmed_at",
	BookingFailureReason: "date_instance.booking_failure_reason",
	VenueProposalStatus:  "date_instance.venue_proposal_status",
	AvailabilitySyncMode: "date_instance.availability_sync_mode",
	CreatedAt:            "date_instance.created_at",
	UpdatedAt:            "date_instance.updated_at",
}

// Generated where

type whereHelpernull_String struct{ field string }

func (w whereHelpernull_String) EQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_String) NEQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_String) LT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_String) LTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_String) GT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_String) GTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_String) LIKE(x null.String) qm.QueryMod {
	return qm.Where(w.field+" LIKE ?", x)
}
func (w whereHelpernull_String) NLIKE(x null.String) qm.QueryMod {
	return qm.Where(w.field+" NOT LIKE ?", x)
}
func (w whereHelpernull_String) ILIKE(x null.String) qm.QueryMod {
	return qm.Where(w.field+" ILIKE ?", x)
}
func (w whereHelpernull_String) NILIKE(x null.String) qm.QueryMod {
	return qm.Where(w.field+" NOT ILIKE ?", x)
}
func (w whereHelpernull_String) SIMILAR(x null.String) qm.QueryMod {
	return qm.Where(w.field+" SIMILAR TO ?", x)
}
func (w whereHelpernull_String) NSIMILAR(x null.String) qm.QueryMod {
	return qm.Where(w.field+" NOT SIMILAR TO ?", x)
}
func (w whereHelpernull_String) IN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_String) NIN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_String) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_String) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpernull_Int struct{ field string }

func (w whereHelpernull_Int) EQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int) NEQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int) LT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int) LTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int) GT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int) GTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Int) IN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Int) NIN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Int) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var DateInstanceWhere = struct {
	ID                   whereHelperstring
	MatchResultRefID     whereHelperstring
	VenueRefID           whereHelpernull_String
	DateTypeCore         whereHelpernull_String
	Status               whereHelperstring
	ScheduledTimeUtc     whereHelpernull_Time
	DurationMinutes      whereHelpernull_Int
	BookingStatus        whereHelpernull_String
	FeedbackStatusUserA  whereHelpernull_String
	DecisionUserA        whereHelpernull_String
	DidMeetUserA         whereHelpernull_String
	FeedbackTextUserA    whereHelpernull_String
	FeedbackStatusUserB  whereHelpernull_String
	DecisionUserB        whereHelpernull_String
	DidMeetUserB         whereHelpernull_String
	FeedbackTextUserB    whereHelpernull_String
	DecisionWindowEnd    whereHelpertime_Time
	InitiatorConfirmedAt whereHelpernull_Time
	ReceiverConfirmedAt  whereHelpernull_Time
	BookingFailureReason whereHelpernull_String
	VenueProposalStatus  whereHelpernull_String
	AvailabilitySyncMode whereHelpernull_String
	CreatedAt            whereHelpertime_Time
	UpdatedAt            whereHelpernull_Time
}{
	ID:                   whereHelperstring{field: "\"date_instance\".\"id\""},
	MatchResultRefID:     whereHelperstring{field: "\"date_instance\".\"match_result_ref_id\""},
	VenueRefID:           whereHelpernull_String{field: "\"date_instance\".\"venue_ref_id\""},
	DateTypeCore:         whereHelpernull_String{field: "\"date_instance\".\"date_type_core\""},
	Status:               whereHelperstring{field: "\"date_instance\".\"status\""},
	ScheduledTimeUtc:     whereHelpernull_Time{field: "\"date_instance\".\"scheduled_time_utc\""},
	DurationMinutes:      whereHelpernull_Int{field: "\"date_instance\".\"duration_minutes\""},
	BookingStatus:        whereHelpernull_String{field: "\"date_instance\".\"booking_status\""},
	FeedbackStatusUserA:  whereHelpernull_String{field: "\"date_instance\".\"feedback_status_user_a\""},
	DecisionUserA:        whereHelpernull_String{field: "\"date_instance\".\"decision_user_a\""},
	DidMeetUserA:         whereHelpernull_String{field: "\"date_instance\".\"did_meet_user_a\""},
	FeedbackTextUserA:    whereHelpernull_String{field: "\"date_instance\".\"feedback_text_user_a\""},
	FeedbackStatusUserB:  whereHelpernull_String{field: "\"date_instance\".\"feedback_status_user_b\""},
	DecisionUserB:        whereHelpernull_String{field: "\"date_instance\".\"decision_user_b\""},
	DidMeetUserB:         whereHelpernull_String{field: "\"date_instance\".\"did_meet_user_b\""},
	FeedbackTextUserB:    whereHelpernull_String{field: "\"date_instance\".\"feedback_text_user_b\""},
	DecisionWindowEnd:    whereHelpertime_Time{field: "\"date_instance\".\"decision_window_end\""},
	InitiatorConfirmedAt: whereHelpernull_Time{field: "\"date_instance\".\"initiator_confirmed_at\""},
	ReceiverConfirmedAt:  whereHelpernull_Time{field: "\"date_instance\".\"receiver_confirmed_at\""},
	BookingFailureReason: whereHelpernull_String{field: "\"date_instance\".\"booking_failure_reason\""},
	VenueProposalStatus:  whereHelpernull_String{field: "\"date_instance\".\"venue_proposal_status\""},
	AvailabilitySyncMode: whereHelpernull_String{field: "\"date_instance\".\"availability_sync_mode\""},
	CreatedAt:            whereHelpertime_Time{field: "\"date_instance\".\"created_at\""},
	UpdatedAt:            whereHelpernull_Time{field: "\"date_instance\".\"updated_at\""},
}

// DateInstanceRels is where relationship names are stored.
var DateInstanceRels = struct {
	MatchResultRef                       string
	VenueRef                             string
	DateInstanceRefBookingReminders      string
	DateInstanceRefDateInstanceLogs      string
	DateInstanceRefDateInstanceProposals string
	CurrentDateInstanceMatchResults      string
	DateInstanceRefSchedulingCards       string
	DateInstanceRefVenueRankingCaches    string
	DateInstanceRefVenueSuggestions      string
}{
	MatchResultRef:                       "MatchResultRef",
	VenueRef:                             "VenueRef",
	DateInstanceRefBookingReminders:      "DateInstanceRefBookingReminders",
	DateInstanceRefDateInstanceLogs:      "DateInstanceRefDateInstanceLogs",
	DateInstanceRefDateInstanceProposals: "DateInstanceRefDateInstanceProposals",
	CurrentDateInstanceMatchResults:      "CurrentDateInstanceMatchResults",
	DateInstanceRefSchedulingCards:       "DateInstanceRefSchedulingCards",
	DateInstanceRefVenueRankingCaches:    "DateInstanceRefVenueRankingCaches",
	DateInstanceRefVenueSuggestions:      "DateInstanceRefVenueSuggestions",
}

// dateInstanceR is where relationships are stored.
type dateInstanceR struct {
	MatchResultRef                       *MatchResult              `boil:"MatchResultRef" json:"MatchResultRef" toml:"MatchResultRef" yaml:"MatchResultRef"`
	VenueRef                             *Venue                    `boil:"VenueRef" json:"VenueRef" toml:"VenueRef" yaml:"VenueRef"`
	DateInstanceRefBookingReminders      BookingReminderSlice      `boil:"DateInstanceRefBookingReminders" json:"DateInstanceRefBookingReminders" toml:"DateInstanceRefBookingReminders" yaml:"DateInstanceRefBookingReminders"`
	DateInstanceRefDateInstanceLogs      DateInstanceLogSlice      `boil:"DateInstanceRefDateInstanceLogs" json:"DateInstanceRefDateInstanceLogs" toml:"DateInstanceRefDateInstanceLogs" yaml:"DateInstanceRefDateInstanceLogs"`
	DateInstanceRefDateInstanceProposals DateInstanceProposalSlice `boil:"DateInstanceRefDateInstanceProposals" json:"DateInstanceRefDateInstanceProposals" toml:"DateInstanceRefDateInstanceProposals" yaml:"DateInstanceRefDateInstanceProposals"`
	CurrentDateInstanceMatchResults      MatchResultSlice          `boil:"CurrentDateInstanceMatchResults" json:"CurrentDateInstanceMatchResults" toml:"CurrentDateInstanceMatchResults" yaml:"CurrentDateInstanceMatchResults"`
	DateInstanceRefSchedulingCards       SchedulingCardSlice       `boil:"DateInstanceRefSchedulingCards" json:"DateInstanceRefSchedulingCards" toml:"DateInstanceRefSchedulingCards" yaml:"DateInstanceRefSchedulingCards"`
	DateInstanceRefVenueRankingCaches    VenueRankingCacheSlice    `boil:"DateInstanceRefVenueRankingCaches" json:"DateInstanceRefVenueRankingCaches" toml:"DateInstanceRefVenueRankingCaches" yaml:"DateInstanceRefVenueRankingCaches"`
	DateInstanceRefVenueSuggestions      VenueSuggestionSlice      `boil:"DateInstanceRefVenueSuggestions" json:"DateInstanceRefVenueSuggestions" toml:"DateInstanceRefVenueSuggestions" yaml:"DateInstanceRefVenueSuggestions"`
}

// NewStruct creates a new relationship struct
func (*dateInstanceR) NewStruct() *dateInstanceR {
	return &dateInstanceR{}
}

func (o *DateInstance) GetMatchResultRef() *MatchResult {
	if o == nil {
		return nil
	}

	return o.R.GetMatchResultRef()
}

func (r *dateInstanceR) GetMatchResultRef() *MatchResult {
	if r == nil {
		return nil
	}

	return r.MatchResultRef
}

func (o *DateInstance) GetVenueRef() *Venue {
	if o == nil {
		return nil
	}

	return o.R.GetVenueRef()
}

func (r *dateInstanceR) GetVenueRef() *Venue {
	if r == nil {
		return nil
	}

	return r.VenueRef
}

func (o *DateInstance) GetDateInstanceRefBookingReminders() BookingReminderSlice {
	if o == nil {
		return nil
	}

	return o.R.GetDateInstanceRefBookingReminders()
}

func (r *dateInstanceR) GetDateInstanceRefBookingReminders() BookingReminderSlice {
	if r == nil {
		return nil
	}

	return r.DateInstanceRefBookingReminders
}

func (o *DateInstance) GetDateInstanceRefDateInstanceLogs() DateInstanceLogSlice {
	if o == nil {
		return nil
	}

	return o.R.GetDateInstanceRefDateInstanceLogs()
}

func (r *dateInstanceR) GetDateInstanceRefDateInstanceLogs() DateInstanceLogSlice {
	if r == nil {
		return nil
	}

	return r.DateInstanceRefDateInstanceLogs
}

func (o *DateInstance) GetDateInstanceRefDateInstanceProposals() DateInstanceProposalSlice {
	if o == nil {
		return nil
	}

	return o.R.GetDateInstanceRefDateInstanceProposals()
}

func (r *dateInstanceR) GetDateInstanceRefDateInstanceProposals() DateInstanceProposalSlice {
	if r == nil {
		return nil
	}

	return r.DateInstanceRefDateInstanceProposals
}

func (o *DateInstance) GetCurrentDateInstanceMatchResults() MatchResultSlice {
	if o == nil {
		return nil
	}

	return o.R.GetCurrentDateInstanceMatchResults()
}

func (r *dateInstanceR) GetCurrentDateInstanceMatchResults() MatchResultSlice {
	if r == nil {
		return nil
	}

	return r.CurrentDateInstanceMatchResults
}

func (o *DateInstance) GetDateInstanceRefSchedulingCards() SchedulingCardSlice {
	if o == nil {
		return nil
	}

	return o.R.GetDateInstanceRefSchedulingCards()
}

func (r *dateInstanceR) GetDateInstanceRefSchedulingCards() SchedulingCardSlice {
	if r == nil {
		return nil
	}

	return r.DateInstanceRefSchedulingCards
}

func (o *DateInstance) GetDateInstanceRefVenueRankingCaches() VenueRankingCacheSlice {
	if o == nil {
		return nil
	}

	return o.R.GetDateInstanceRefVenueRankingCaches()
}

func (r *dateInstanceR) GetDateInstanceRefVenueRankingCaches() VenueRankingCacheSlice {
	if r == nil {
		return nil
	}

	return r.DateInstanceRefVenueRankingCaches
}

func (o *DateInstance) GetDateInstanceRefVenueSuggestions() VenueSuggestionSlice {
	if o == nil {
		return nil
	}

	return o.R.GetDateInstanceRefVenueSuggestions()
}

func (r *dateInstanceR) GetDateInstanceRefVenueSuggestions() VenueSuggestionSlice {
	if r == nil {
		return nil
	}

	return r.DateInstanceRefVenueSuggestions
}

// dateInstanceL is where Load methods for each relationship are stored.
type dateInstanceL struct{}

var (
	dateInstanceAllColumns            = []string{"id", "match_result_ref_id", "venue_ref_id", "date_type_core", "status", "scheduled_time_utc", "duration_minutes", "booking_status", "feedback_status_user_a", "decision_user_a", "did_meet_user_a", "feedback_text_user_a", "feedback_status_user_b", "decision_user_b", "did_meet_user_b", "feedback_text_user_b", "decision_window_end", "initiator_confirmed_at", "receiver_confirmed_at", "booking_failure_reason", "venue_proposal_status", "availability_sync_mode", "created_at", "updated_at"}
	dateInstanceColumnsWithoutDefault = []string{"match_result_ref_id", "decision_window_end"}
	dateInstanceColumnsWithDefault    = []string{"id", "venue_ref_id", "date_type_core", "status", "scheduled_time_utc", "duration_minutes", "booking_status", "feedback_status_user_a", "decision_user_a", "did_meet_user_a", "feedback_text_user_a", "feedback_status_user_b", "decision_user_b", "did_meet_user_b", "feedback_text_user_b", "initiator_confirmed_at", "receiver_confirmed_at", "booking_failure_reason", "venue_proposal_status", "availability_sync_mode", "created_at", "updated_at"}
	dateInstancePrimaryKeyColumns     = []string{"id"}
	dateInstanceGeneratedColumns      = []string{}
)

type (
	// DateInstanceSlice is an alias for a slice of pointers to DateInstance.
	// This should almost always be used instead of []DateInstance.
	DateInstanceSlice []*DateInstance
	// DateInstanceHook is the signature for custom DateInstance hook methods
	DateInstanceHook func(context.Context, boil.ContextExecutor, *DateInstance) error

	dateInstanceQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	dateInstanceType                 = reflect.TypeOf(&DateInstance{})
	dateInstanceMapping              = queries.MakeStructMapping(dateInstanceType)
	dateInstancePrimaryKeyMapping, _ = queries.BindMapping(dateInstanceType, dateInstanceMapping, dateInstancePrimaryKeyColumns)
	dateInstanceInsertCacheMut       sync.RWMutex
	dateInstanceInsertCache          = make(map[string]insertCache)
	dateInstanceUpdateCacheMut       sync.RWMutex
	dateInstanceUpdateCache          = make(map[string]updateCache)
	dateInstanceUpsertCacheMut       sync.RWMutex
	dateInstanceUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var dateInstanceAfterSelectMu sync.Mutex
var dateInstanceAfterSelectHooks []DateInstanceHook

var dateInstanceBeforeInsertMu sync.Mutex
var dateInstanceBeforeInsertHooks []DateInstanceHook
var dateInstanceAfterInsertMu sync.Mutex
var dateInstanceAfterInsertHooks []DateInstanceHook

var dateInstanceBeforeUpdateMu sync.Mutex
var dateInstanceBeforeUpdateHooks []DateInstanceHook
var dateInstanceAfterUpdateMu sync.Mutex
var dateInstanceAfterUpdateHooks []DateInstanceHook

var dateInstanceBeforeDeleteMu sync.Mutex
var dateInstanceBeforeDeleteHooks []DateInstanceHook
var dateInstanceAfterDeleteMu sync.Mutex
var dateInstanceAfterDeleteHooks []DateInstanceHook

var dateInstanceBeforeUpsertMu sync.Mutex
var dateInstanceBeforeUpsertHooks []DateInstanceHook
var dateInstanceAfterUpsertMu sync.Mutex
var dateInstanceAfterUpsertHooks []DateInstanceHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *DateInstance) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dateInstanceAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *DateInstance) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dateInstanceBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *DateInstance) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dateInstanceAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *DateInstance) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dateInstanceBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *DateInstance) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dateInstanceAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *DateInstance) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dateInstanceBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *DateInstance) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dateInstanceAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *DateInstance) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dateInstanceBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *DateInstance) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dateInstanceAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddDateInstanceHook registers your hook function for all future operations.
func AddDateInstanceHook(hookPoint boil.HookPoint, dateInstanceHook DateInstanceHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		dateInstanceAfterSelectMu.Lock()
		dateInstanceAfterSelectHooks = append(dateInstanceAfterSelectHooks, dateInstanceHook)
		dateInstanceAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		dateInstanceBeforeInsertMu.Lock()
		dateInstanceBeforeInsertHooks = append(dateInstanceBeforeInsertHooks, dateInstanceHook)
		dateInstanceBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		dateInstanceAfterInsertMu.Lock()
		dateInstanceAfterInsertHooks = append(dateInstanceAfterInsertHooks, dateInstanceHook)
		dateInstanceAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		dateInstanceBeforeUpdateMu.Lock()
		dateInstanceBeforeUpdateHooks = append(dateInstanceBeforeUpdateHooks, dateInstanceHook)
		dateInstanceBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		dateInstanceAfterUpdateMu.Lock()
		dateInstanceAfterUpdateHooks = append(dateInstanceAfterUpdateHooks, dateInstanceHook)
		dateInstanceAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		dateInstanceBeforeDeleteMu.Lock()
		dateInstanceBeforeDeleteHooks = append(dateInstanceBeforeDeleteHooks, dateInstanceHook)
		dateInstanceBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		dateInstanceAfterDeleteMu.Lock()
		dateInstanceAfterDeleteHooks = append(dateInstanceAfterDeleteHooks, dateInstanceHook)
		dateInstanceAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		dateInstanceBeforeUpsertMu.Lock()
		dateInstanceBeforeUpsertHooks = append(dateInstanceBeforeUpsertHooks, dateInstanceHook)
		dateInstanceBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		dateInstanceAfterUpsertMu.Lock()
		dateInstanceAfterUpsertHooks = append(dateInstanceAfterUpsertHooks, dateInstanceHook)
		dateInstanceAfterUpsertMu.Unlock()
	}
}

// One returns a single dateInstance record from the query.
func (q dateInstanceQuery) One(ctx context.Context, exec boil.ContextExecutor) (*DateInstance, error) {
	o := &DateInstance{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "pgmodel: failed to execute a one query for date_instance")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all DateInstance records from the query.
func (q dateInstanceQuery) All(ctx context.Context, exec boil.ContextExecutor) (DateInstanceSlice, error) {
	var o []*DateInstance

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "pgmodel: failed to assign all query results to DateInstance slice")
	}

	if len(dateInstanceAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all DateInstance records in the query.
func (q dateInstanceQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: failed to count date_instance rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q dateInstanceQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "pgmodel: failed to check if date_instance exists")
	}

	return count > 0, nil
}

// MatchResultRef pointed to by the foreign key.
func (o *DateInstance) MatchResultRef(mods ...qm.QueryMod) matchResultQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.MatchResultRefID),
	}

	queryMods = append(queryMods, mods...)

	return MatchResults(queryMods...)
}

// VenueRef pointed to by the foreign key.
func (o *DateInstance) VenueRef(mods ...qm.QueryMod) venueQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.VenueRefID),
	}

	queryMods = append(queryMods, mods...)

	return Venues(queryMods...)
}

// DateInstanceRefBookingReminders retrieves all the booking_reminder's BookingReminders with an executor via date_instance_ref_id column.
func (o *DateInstance) DateInstanceRefBookingReminders(mods ...qm.QueryMod) bookingReminderQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"booking_reminder\".\"date_instance_ref_id\"=?", o.ID),
	)

	return BookingReminders(queryMods...)
}

// DateInstanceRefDateInstanceLogs retrieves all the date_instance_log's DateInstanceLogs with an executor via date_instance_ref_id column.
func (o *DateInstance) DateInstanceRefDateInstanceLogs(mods ...qm.QueryMod) dateInstanceLogQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"date_instance_log\".\"date_instance_ref_id\"=?", o.ID),
	)

	return DateInstanceLogs(queryMods...)
}

// DateInstanceRefDateInstanceProposals retrieves all the date_instance_proposal's DateInstanceProposals with an executor via date_instance_ref_id column.
func (o *DateInstance) DateInstanceRefDateInstanceProposals(mods ...qm.QueryMod) dateInstanceProposalQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"date_instance_proposal\".\"date_instance_ref_id\"=?", o.ID),
	)

	return DateInstanceProposals(queryMods...)
}

// CurrentDateInstanceMatchResults retrieves all the match_result's MatchResults with an executor via current_date_instance_id column.
func (o *DateInstance) CurrentDateInstanceMatchResults(mods ...qm.QueryMod) matchResultQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"match_result\".\"current_date_instance_id\"=?", o.ID),
	)

	return MatchResults(queryMods...)
}

// DateInstanceRefSchedulingCards retrieves all the scheduling_card's SchedulingCards with an executor via date_instance_ref_id column.
func (o *DateInstance) DateInstanceRefSchedulingCards(mods ...qm.QueryMod) schedulingCardQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"scheduling_card\".\"date_instance_ref_id\"=?", o.ID),
	)

	return SchedulingCards(queryMods...)
}

// DateInstanceRefVenueRankingCaches retrieves all the venue_ranking_cache's VenueRankingCaches with an executor via date_instance_ref_id column.
func (o *DateInstance) DateInstanceRefVenueRankingCaches(mods ...qm.QueryMod) venueRankingCacheQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"venue_ranking_cache\".\"date_instance_ref_id\"=?", o.ID),
	)

	return VenueRankingCaches(queryMods...)
}

// DateInstanceRefVenueSuggestions retrieves all the venue_suggestion's VenueSuggestions with an executor via date_instance_ref_id column.
func (o *DateInstance) DateInstanceRefVenueSuggestions(mods ...qm.QueryMod) venueSuggestionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"venue_suggestion\".\"date_instance_ref_id\"=?", o.ID),
	)

	return VenueSuggestions(queryMods...)
}

// LoadMatchResultRef allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dateInstanceL) LoadMatchResultRef(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDateInstance interface{}, mods queries.Applicator) error {
	var slice []*DateInstance
	var object *DateInstance

	if singular {
		var ok bool
		object, ok = maybeDateInstance.(*DateInstance)
		if !ok {
			object = new(DateInstance)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDateInstance)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDateInstance))
			}
		}
	} else {
		s, ok := maybeDateInstance.(*[]*DateInstance)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDateInstance)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDateInstance))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &dateInstanceR{}
		}
		args[object.MatchResultRefID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dateInstanceR{}
			}

			args[obj.MatchResultRefID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`match_result`),
		qm.WhereIn(`match_result.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load MatchResult")
	}

	var resultSlice []*MatchResult
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice MatchResult")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for match_result")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for match_result")
	}

	if len(matchResultAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.MatchResultRef = foreign
		if foreign.R == nil {
			foreign.R = &matchResultR{}
		}
		foreign.R.MatchResultRefDateInstances = append(foreign.R.MatchResultRefDateInstances, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.MatchResultRefID == foreign.ID {
				local.R.MatchResultRef = foreign
				if foreign.R == nil {
					foreign.R = &matchResultR{}
				}
				foreign.R.MatchResultRefDateInstances = append(foreign.R.MatchResultRefDateInstances, local)
				break
			}
		}
	}

	return nil
}

// LoadVenueRef allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dateInstanceL) LoadVenueRef(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDateInstance interface{}, mods queries.Applicator) error {
	var slice []*DateInstance
	var object *DateInstance

	if singular {
		var ok bool
		object, ok = maybeDateInstance.(*DateInstance)
		if !ok {
			object = new(DateInstance)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDateInstance)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDateInstance))
			}
		}
	} else {
		s, ok := maybeDateInstance.(*[]*DateInstance)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDateInstance)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDateInstance))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &dateInstanceR{}
		}
		if !queries.IsNil(object.VenueRefID) {
			args[object.VenueRefID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dateInstanceR{}
			}

			if !queries.IsNil(obj.VenueRefID) {
				args[obj.VenueRefID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`venue`),
		qm.WhereIn(`venue.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Venue")
	}

	var resultSlice []*Venue
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Venue")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for venue")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for venue")
	}

	if len(venueAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.VenueRef = foreign
		if foreign.R == nil {
			foreign.R = &venueR{}
		}
		foreign.R.VenueRefDateInstances = append(foreign.R.VenueRefDateInstances, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.VenueRefID, foreign.ID) {
				local.R.VenueRef = foreign
				if foreign.R == nil {
					foreign.R = &venueR{}
				}
				foreign.R.VenueRefDateInstances = append(foreign.R.VenueRefDateInstances, local)
				break
			}
		}
	}

	return nil
}

// LoadDateInstanceRefBookingReminders allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dateInstanceL) LoadDateInstanceRefBookingReminders(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDateInstance interface{}, mods queries.Applicator) error {
	var slice []*DateInstance
	var object *DateInstance

	if singular {
		var ok bool
		object, ok = maybeDateInstance.(*DateInstance)
		if !ok {
			object = new(DateInstance)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDateInstance)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDateInstance))
			}
		}
	} else {
		s, ok := maybeDateInstance.(*[]*DateInstance)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDateInstance)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDateInstance))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &dateInstanceR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dateInstanceR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`booking_reminder`),
		qm.WhereIn(`booking_reminder.date_instance_ref_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load booking_reminder")
	}

	var resultSlice []*BookingReminder
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice booking_reminder")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on booking_reminder")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for booking_reminder")
	}

	if len(bookingReminderAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.DateInstanceRefBookingReminders = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &bookingReminderR{}
			}
			foreign.R.DateInstanceRef = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.DateInstanceRefID {
				local.R.DateInstanceRefBookingReminders = append(local.R.DateInstanceRefBookingReminders, foreign)
				if foreign.R == nil {
					foreign.R = &bookingReminderR{}
				}
				foreign.R.DateInstanceRef = local
				break
			}
		}
	}

	return nil
}

// LoadDateInstanceRefDateInstanceLogs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dateInstanceL) LoadDateInstanceRefDateInstanceLogs(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDateInstance interface{}, mods queries.Applicator) error {
	var slice []*DateInstance
	var object *DateInstance

	if singular {
		var ok bool
		object, ok = maybeDateInstance.(*DateInstance)
		if !ok {
			object = new(DateInstance)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDateInstance)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDateInstance))
			}
		}
	} else {
		s, ok := maybeDateInstance.(*[]*DateInstance)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDateInstance)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDateInstance))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &dateInstanceR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dateInstanceR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`date_instance_log`),
		qm.WhereIn(`date_instance_log.date_instance_ref_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load date_instance_log")
	}

	var resultSlice []*DateInstanceLog
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice date_instance_log")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on date_instance_log")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for date_instance_log")
	}

	if len(dateInstanceLogAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.DateInstanceRefDateInstanceLogs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dateInstanceLogR{}
			}
			foreign.R.DateInstanceRef = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.DateInstanceRefID {
				local.R.DateInstanceRefDateInstanceLogs = append(local.R.DateInstanceRefDateInstanceLogs, foreign)
				if foreign.R == nil {
					foreign.R = &dateInstanceLogR{}
				}
				foreign.R.DateInstanceRef = local
				break
			}
		}
	}

	return nil
}

// LoadDateInstanceRefDateInstanceProposals allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dateInstanceL) LoadDateInstanceRefDateInstanceProposals(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDateInstance interface{}, mods queries.Applicator) error {
	var slice []*DateInstance
	var object *DateInstance

	if singular {
		var ok bool
		object, ok = maybeDateInstance.(*DateInstance)
		if !ok {
			object = new(DateInstance)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDateInstance)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDateInstance))
			}
		}
	} else {
		s, ok := maybeDateInstance.(*[]*DateInstance)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDateInstance)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDateInstance))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &dateInstanceR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dateInstanceR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`date_instance_proposal`),
		qm.WhereIn(`date_instance_proposal.date_instance_ref_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load date_instance_proposal")
	}

	var resultSlice []*DateInstanceProposal
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice date_instance_proposal")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on date_instance_proposal")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for date_instance_proposal")
	}

	if len(dateInstanceProposalAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.DateInstanceRefDateInstanceProposals = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dateInstanceProposalR{}
			}
			foreign.R.DateInstanceRef = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.DateInstanceRefID {
				local.R.DateInstanceRefDateInstanceProposals = append(local.R.DateInstanceRefDateInstanceProposals, foreign)
				if foreign.R == nil {
					foreign.R = &dateInstanceProposalR{}
				}
				foreign.R.DateInstanceRef = local
				break
			}
		}
	}

	return nil
}

// LoadCurrentDateInstanceMatchResults allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dateInstanceL) LoadCurrentDateInstanceMatchResults(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDateInstance interface{}, mods queries.Applicator) error {
	var slice []*DateInstance
	var object *DateInstance

	if singular {
		var ok bool
		object, ok = maybeDateInstance.(*DateInstance)
		if !ok {
			object = new(DateInstance)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDateInstance)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDateInstance))
			}
		}
	} else {
		s, ok := maybeDateInstance.(*[]*DateInstance)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDateInstance)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDateInstance))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &dateInstanceR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dateInstanceR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`match_result`),
		qm.WhereIn(`match_result.current_date_instance_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load match_result")
	}

	var resultSlice []*MatchResult
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice match_result")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on match_result")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for match_result")
	}

	if len(matchResultAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CurrentDateInstanceMatchResults = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &matchResultR{}
			}
			foreign.R.CurrentDateInstance = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CurrentDateInstanceID) {
				local.R.CurrentDateInstanceMatchResults = append(local.R.CurrentDateInstanceMatchResults, foreign)
				if foreign.R == nil {
					foreign.R = &matchResultR{}
				}
				foreign.R.CurrentDateInstance = local
				break
			}
		}
	}

	return nil
}

// LoadDateInstanceRefSchedulingCards allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dateInstanceL) LoadDateInstanceRefSchedulingCards(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDateInstance interface{}, mods queries.Applicator) error {
	var slice []*DateInstance
	var object *DateInstance

	if singular {
		var ok bool
		object, ok = maybeDateInstance.(*DateInstance)
		if !ok {
			object = new(DateInstance)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDateInstance)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDateInstance))
			}
		}
	} else {
		s, ok := maybeDateInstance.(*[]*DateInstance)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDateInstance)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDateInstance))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &dateInstanceR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dateInstanceR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`scheduling_card`),
		qm.WhereIn(`scheduling_card.date_instance_ref_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load scheduling_card")
	}

	var resultSlice []*SchedulingCard
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice scheduling_card")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on scheduling_card")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for scheduling_card")
	}

	if len(schedulingCardAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.DateInstanceRefSchedulingCards = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &schedulingCardR{}
			}
			foreign.R.DateInstanceRef = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.DateInstanceRefID {
				local.R.DateInstanceRefSchedulingCards = append(local.R.DateInstanceRefSchedulingCards, foreign)
				if foreign.R == nil {
					foreign.R = &schedulingCardR{}
				}
				foreign.R.DateInstanceRef = local
				break
			}
		}
	}

	return nil
}

// LoadDateInstanceRefVenueRankingCaches allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dateInstanceL) LoadDateInstanceRefVenueRankingCaches(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDateInstance interface{}, mods queries.Applicator) error {
	var slice []*DateInstance
	var object *DateInstance

	if singular {
		var ok bool
		object, ok = maybeDateInstance.(*DateInstance)
		if !ok {
			object = new(DateInstance)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDateInstance)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDateInstance))
			}
		}
	} else {
		s, ok := maybeDateInstance.(*[]*DateInstance)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDateInstance)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDateInstance))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &dateInstanceR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dateInstanceR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`venue_ranking_cache`),
		qm.WhereIn(`venue_ranking_cache.date_instance_ref_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load venue_ranking_cache")
	}

	var resultSlice []*VenueRankingCache
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice venue_ranking_cache")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on venue_ranking_cache")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for venue_ranking_cache")
	}

	if len(venueRankingCacheAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.DateInstanceRefVenueRankingCaches = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &venueRankingCacheR{}
			}
			foreign.R.DateInstanceRef = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.DateInstanceRefID {
				local.R.DateInstanceRefVenueRankingCaches = append(local.R.DateInstanceRefVenueRankingCaches, foreign)
				if foreign.R == nil {
					foreign.R = &venueRankingCacheR{}
				}
				foreign.R.DateInstanceRef = local
				break
			}
		}
	}

	return nil
}

// LoadDateInstanceRefVenueSuggestions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dateInstanceL) LoadDateInstanceRefVenueSuggestions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDateInstance interface{}, mods queries.Applicator) error {
	var slice []*DateInstance
	var object *DateInstance

	if singular {
		var ok bool
		object, ok = maybeDateInstance.(*DateInstance)
		if !ok {
			object = new(DateInstance)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDateInstance)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDateInstance))
			}
		}
	} else {
		s, ok := maybeDateInstance.(*[]*DateInstance)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDateInstance)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDateInstance))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &dateInstanceR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dateInstanceR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`venue_suggestion`),
		qm.WhereIn(`venue_suggestion.date_instance_ref_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load venue_suggestion")
	}

	var resultSlice []*VenueSuggestion
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice venue_suggestion")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on venue_suggestion")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for venue_suggestion")
	}

	if len(venueSuggestionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.DateInstanceRefVenueSuggestions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &venueSuggestionR{}
			}
			foreign.R.DateInstanceRef = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.DateInstanceRefID {
				local.R.DateInstanceRefVenueSuggestions = append(local.R.DateInstanceRefVenueSuggestions, foreign)
				if foreign.R == nil {
					foreign.R = &venueSuggestionR{}
				}
				foreign.R.DateInstanceRef = local
				break
			}
		}
	}

	return nil
}

// SetMatchResultRef of the dateInstance to the related item.
// Sets o.R.MatchResultRef to related.
// Adds o to related.R.MatchResultRefDateInstances.
func (o *DateInstance) SetMatchResultRef(ctx context.Context, exec boil.ContextExecutor, insert bool, related *MatchResult) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"date_instance\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"match_result_ref_id"}),
		strmangle.WhereClause("\"", "\"", 2, dateInstancePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.MatchResultRefID = related.ID
	if o.R == nil {
		o.R = &dateInstanceR{
			MatchResultRef: related,
		}
	} else {
		o.R.MatchResultRef = related
	}

	if related.R == nil {
		related.R = &matchResultR{
			MatchResultRefDateInstances: DateInstanceSlice{o},
		}
	} else {
		related.R.MatchResultRefDateInstances = append(related.R.MatchResultRefDateInstances, o)
	}

	return nil
}

// SetVenueRef of the dateInstance to the related item.
// Sets o.R.VenueRef to related.
// Adds o to related.R.VenueRefDateInstances.
func (o *DateInstance) SetVenueRef(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Venue) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"date_instance\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"venue_ref_id"}),
		strmangle.WhereClause("\"", "\"", 2, dateInstancePrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.VenueRefID, related.ID)
	if o.R == nil {
		o.R = &dateInstanceR{
			VenueRef: related,
		}
	} else {
		o.R.VenueRef = related
	}

	if related.R == nil {
		related.R = &venueR{
			VenueRefDateInstances: DateInstanceSlice{o},
		}
	} else {
		related.R.VenueRefDateInstances = append(related.R.VenueRefDateInstances, o)
	}

	return nil
}

// RemoveVenueRef relationship.
// Sets o.R.VenueRef to nil.
// Removes o from all passed in related items' relationships struct.
func (o *DateInstance) RemoveVenueRef(ctx context.Context, exec boil.ContextExecutor, related *Venue) error {
	var err error

	queries.SetScanner(&o.VenueRefID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("venue_ref_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.VenueRef = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.VenueRefDateInstances {
		if queries.Equal(o.VenueRefID, ri.VenueRefID) {
			continue
		}

		ln := len(related.R.VenueRefDateInstances)
		if ln > 1 && i < ln-1 {
			related.R.VenueRefDateInstances[i] = related.R.VenueRefDateInstances[ln-1]
		}
		related.R.VenueRefDateInstances = related.R.VenueRefDateInstances[:ln-1]
		break
	}
	return nil
}

// AddDateInstanceRefBookingReminders adds the given related objects to the existing relationships
// of the date_instance, optionally inserting them as new records.
// Appends related to o.R.DateInstanceRefBookingReminders.
// Sets related.R.DateInstanceRef appropriately.
func (o *DateInstance) AddDateInstanceRefBookingReminders(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*BookingReminder) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.DateInstanceRefID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"booking_reminder\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"date_instance_ref_id"}),
				strmangle.WhereClause("\"", "\"", 2, bookingReminderPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.DateInstanceRefID = o.ID
		}
	}

	if o.R == nil {
		o.R = &dateInstanceR{
			DateInstanceRefBookingReminders: related,
		}
	} else {
		o.R.DateInstanceRefBookingReminders = append(o.R.DateInstanceRefBookingReminders, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &bookingReminderR{
				DateInstanceRef: o,
			}
		} else {
			rel.R.DateInstanceRef = o
		}
	}
	return nil
}

// AddDateInstanceRefDateInstanceLogs adds the given related objects to the existing relationships
// of the date_instance, optionally inserting them as new records.
// Appends related to o.R.DateInstanceRefDateInstanceLogs.
// Sets related.R.DateInstanceRef appropriately.
func (o *DateInstance) AddDateInstanceRefDateInstanceLogs(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DateInstanceLog) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.DateInstanceRefID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"date_instance_log\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"date_instance_ref_id"}),
				strmangle.WhereClause("\"", "\"", 2, dateInstanceLogPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.DateInstanceRefID = o.ID
		}
	}

	if o.R == nil {
		o.R = &dateInstanceR{
			DateInstanceRefDateInstanceLogs: related,
		}
	} else {
		o.R.DateInstanceRefDateInstanceLogs = append(o.R.DateInstanceRefDateInstanceLogs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dateInstanceLogR{
				DateInstanceRef: o,
			}
		} else {
			rel.R.DateInstanceRef = o
		}
	}
	return nil
}

// AddDateInstanceRefDateInstanceProposals adds the given related objects to the existing relationships
// of the date_instance, optionally inserting them as new records.
// Appends related to o.R.DateInstanceRefDateInstanceProposals.
// Sets related.R.DateInstanceRef appropriately.
func (o *DateInstance) AddDateInstanceRefDateInstanceProposals(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DateInstanceProposal) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.DateInstanceRefID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"date_instance_proposal\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"date_instance_ref_id"}),
				strmangle.WhereClause("\"", "\"", 2, dateInstanceProposalPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.DateInstanceRefID = o.ID
		}
	}

	if o.R == nil {
		o.R = &dateInstanceR{
			DateInstanceRefDateInstanceProposals: related,
		}
	} else {
		o.R.DateInstanceRefDateInstanceProposals = append(o.R.DateInstanceRefDateInstanceProposals, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dateInstanceProposalR{
				DateInstanceRef: o,
			}
		} else {
			rel.R.DateInstanceRef = o
		}
	}
	return nil
}

// AddCurrentDateInstanceMatchResults adds the given related objects to the existing relationships
// of the date_instance, optionally inserting them as new records.
// Appends related to o.R.CurrentDateInstanceMatchResults.
// Sets related.R.CurrentDateInstance appropriately.
func (o *DateInstance) AddCurrentDateInstanceMatchResults(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MatchResult) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CurrentDateInstanceID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"match_result\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"current_date_instance_id"}),
				strmangle.WhereClause("\"", "\"", 2, matchResultPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CurrentDateInstanceID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &dateInstanceR{
			CurrentDateInstanceMatchResults: related,
		}
	} else {
		o.R.CurrentDateInstanceMatchResults = append(o.R.CurrentDateInstanceMatchResults, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &matchResultR{
				CurrentDateInstance: o,
			}
		} else {
			rel.R.CurrentDateInstance = o
		}
	}
	return nil
}

// SetCurrentDateInstanceMatchResults removes all previously related items of the
// date_instance replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.CurrentDateInstance's CurrentDateInstanceMatchResults accordingly.
// Replaces o.R.CurrentDateInstanceMatchResults with related.
// Sets related.R.CurrentDateInstance's CurrentDateInstanceMatchResults accordingly.
func (o *DateInstance) SetCurrentDateInstanceMatchResults(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MatchResult) error {
	query := "update \"match_result\" set \"current_date_instance_id\" = null where \"current_date_instance_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CurrentDateInstanceMatchResults {
			queries.SetScanner(&rel.CurrentDateInstanceID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.CurrentDateInstance = nil
		}
		o.R.CurrentDateInstanceMatchResults = nil
	}

	return o.AddCurrentDateInstanceMatchResults(ctx, exec, insert, related...)
}

// RemoveCurrentDateInstanceMatchResults relationships from objects passed in.
// Removes related items from R.CurrentDateInstanceMatchResults (uses pointer comparison, removal does not keep order)
// Sets related.R.CurrentDateInstance.
func (o *DateInstance) RemoveCurrentDateInstanceMatchResults(ctx context.Context, exec boil.ContextExecutor, related ...*MatchResult) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CurrentDateInstanceID, nil)
		if rel.R != nil {
			rel.R.CurrentDateInstance = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("current_date_instance_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CurrentDateInstanceMatchResults {
			if rel != ri {
				continue
			}

			ln := len(o.R.CurrentDateInstanceMatchResults)
			if ln > 1 && i < ln-1 {
				o.R.CurrentDateInstanceMatchResults[i] = o.R.CurrentDateInstanceMatchResults[ln-1]
			}
			o.R.CurrentDateInstanceMatchResults = o.R.CurrentDateInstanceMatchResults[:ln-1]
			break
		}
	}

	return nil
}

// AddDateInstanceRefSchedulingCards adds the given related objects to the existing relationships
// of the date_instance, optionally inserting them as new records.
// Appends related to o.R.DateInstanceRefSchedulingCards.
// Sets related.R.DateInstanceRef appropriately.
func (o *DateInstance) AddDateInstanceRefSchedulingCards(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SchedulingCard) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.DateInstanceRefID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"scheduling_card\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"date_instance_ref_id"}),
				strmangle.WhereClause("\"", "\"", 2, schedulingCardPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.DateInstanceRefID = o.ID
		}
	}

	if o.R == nil {
		o.R = &dateInstanceR{
			DateInstanceRefSchedulingCards: related,
		}
	} else {
		o.R.DateInstanceRefSchedulingCards = append(o.R.DateInstanceRefSchedulingCards, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &schedulingCardR{
				DateInstanceRef: o,
			}
		} else {
			rel.R.DateInstanceRef = o
		}
	}
	return nil
}

// AddDateInstanceRefVenueRankingCaches adds the given related objects to the existing relationships
// of the date_instance, optionally inserting them as new records.
// Appends related to o.R.DateInstanceRefVenueRankingCaches.
// Sets related.R.DateInstanceRef appropriately.
func (o *DateInstance) AddDateInstanceRefVenueRankingCaches(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*VenueRankingCache) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.DateInstanceRefID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"venue_ranking_cache\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"date_instance_ref_id"}),
				strmangle.WhereClause("\"", "\"", 2, venueRankingCachePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.DateInstanceRefID = o.ID
		}
	}

	if o.R == nil {
		o.R = &dateInstanceR{
			DateInstanceRefVenueRankingCaches: related,
		}
	} else {
		o.R.DateInstanceRefVenueRankingCaches = append(o.R.DateInstanceRefVenueRankingCaches, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &venueRankingCacheR{
				DateInstanceRef: o,
			}
		} else {
			rel.R.DateInstanceRef = o
		}
	}
	return nil
}

// AddDateInstanceRefVenueSuggestions adds the given related objects to the existing relationships
// of the date_instance, optionally inserting them as new records.
// Appends related to o.R.DateInstanceRefVenueSuggestions.
// Sets related.R.DateInstanceRef appropriately.
func (o *DateInstance) AddDateInstanceRefVenueSuggestions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*VenueSuggestion) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.DateInstanceRefID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"venue_suggestion\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"date_instance_ref_id"}),
				strmangle.WhereClause("\"", "\"", 2, venueSuggestionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.DateInstanceRefID = o.ID
		}
	}

	if o.R == nil {
		o.R = &dateInstanceR{
			DateInstanceRefVenueSuggestions: related,
		}
	} else {
		o.R.DateInstanceRefVenueSuggestions = append(o.R.DateInstanceRefVenueSuggestions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &venueSuggestionR{
				DateInstanceRef: o,
			}
		} else {
			rel.R.DateInstanceRef = o
		}
	}
	return nil
}

// DateInstances retrieves all the records using an executor.
func DateInstances(mods ...qm.QueryMod) dateInstanceQuery {
	mods = append(mods, qm.From("\"date_instance\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"date_instance\".*"})
	}

	return dateInstanceQuery{q}
}

// FindDateInstance retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDateInstance(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*DateInstance, error) {
	dateInstanceObj := &DateInstance{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"date_instance\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, dateInstanceObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "pgmodel: unable to select from date_instance")
	}

	if err = dateInstanceObj.doAfterSelectHooks(ctx, exec); err != nil {
		return dateInstanceObj, err
	}

	return dateInstanceObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *DateInstance) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("pgmodel: no date_instance provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(dateInstanceColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	dateInstanceInsertCacheMut.RLock()
	cache, cached := dateInstanceInsertCache[key]
	dateInstanceInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			dateInstanceAllColumns,
			dateInstanceColumnsWithDefault,
			dateInstanceColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(dateInstanceType, dateInstanceMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(dateInstanceType, dateInstanceMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"date_instance\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"date_instance\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "pgmodel: unable to insert into date_instance")
	}

	if !cached {
		dateInstanceInsertCacheMut.Lock()
		dateInstanceInsertCache[key] = cache
		dateInstanceInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the DateInstance.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *DateInstance) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	dateInstanceUpdateCacheMut.RLock()
	cache, cached := dateInstanceUpdateCache[key]
	dateInstanceUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			dateInstanceAllColumns,
			dateInstancePrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("pgmodel: unable to update date_instance, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"date_instance\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, dateInstancePrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(dateInstanceType, dateInstanceMapping, append(wl, dateInstancePrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to update date_instance row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: failed to get rows affected by update for date_instance")
	}

	if !cached {
		dateInstanceUpdateCacheMut.Lock()
		dateInstanceUpdateCache[key] = cache
		dateInstanceUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q dateInstanceQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to update all for date_instance")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to retrieve rows affected for date_instance")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DateInstanceSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("pgmodel: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dateInstancePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"date_instance\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, dateInstancePrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to update all in dateInstance slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to retrieve rows affected all in update all dateInstance")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *DateInstance) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("pgmodel: no date_instance provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(dateInstanceColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	dateInstanceUpsertCacheMut.RLock()
	cache, cached := dateInstanceUpsertCache[key]
	dateInstanceUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			dateInstanceAllColumns,
			dateInstanceColumnsWithDefault,
			dateInstanceColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			dateInstanceAllColumns,
			dateInstancePrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("pgmodel: unable to upsert date_instance, could not build update column list")
		}

		ret := strmangle.SetComplement(dateInstanceAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(dateInstancePrimaryKeyColumns) == 0 {
				return errors.New("pgmodel: unable to upsert date_instance, could not build conflict column list")
			}

			conflict = make([]string, len(dateInstancePrimaryKeyColumns))
			copy(conflict, dateInstancePrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"date_instance\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(dateInstanceType, dateInstanceMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(dateInstanceType, dateInstanceMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "pgmodel: unable to upsert date_instance")
	}

	if !cached {
		dateInstanceUpsertCacheMut.Lock()
		dateInstanceUpsertCache[key] = cache
		dateInstanceUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single DateInstance record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *DateInstance) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("pgmodel: no DateInstance provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), dateInstancePrimaryKeyMapping)
	sql := "DELETE FROM \"date_instance\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to delete from date_instance")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: failed to get rows affected by delete for date_instance")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q dateInstanceQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("pgmodel: no dateInstanceQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to delete all from date_instance")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: failed to get rows affected by deleteall for date_instance")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DateInstanceSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(dateInstanceBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dateInstancePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"date_instance\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, dateInstancePrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to delete all from dateInstance slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: failed to get rows affected by deleteall for date_instance")
	}

	if len(dateInstanceAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *DateInstance) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindDateInstance(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DateInstanceSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DateInstanceSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dateInstancePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"date_instance\".* FROM \"date_instance\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, dateInstancePrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "pgmodel: unable to reload all in DateInstanceSlice")
	}

	*o = slice

	return nil
}

// DateInstanceExists checks if the DateInstance row exists.
func DateInstanceExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"date_instance\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "pgmodel: unable to check if date_instance exists")
	}

	return exists, nil
}

// Exists checks if the DateInstance row exists.
func (o *DateInstance) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return DateInstanceExists(ctx, exec, o.ID)
}
