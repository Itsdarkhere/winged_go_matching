// Code generated by SQLBoiler 4.19.5 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package pgmodel

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/sqlboiler/v4/types"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// MatchConfig is an object representing the database table.
type MatchConfig struct {
	ID                        string            `boil:"id" json:"id" toml:"id" yaml:"id"`
	AgeRangeStart             null.Int          `boil:"age_range_start" json:"age_range_start,omitempty" toml:"age_range_start" yaml:"age_range_start,omitempty"`
	AgeRangeEnd               null.Int          `boil:"age_range_end" json:"age_range_end,omitempty" toml:"age_range_end" yaml:"age_range_end,omitempty"`
	AgeRangeWomanOlderBy      int               `boil:"age_range_woman_older_by" json:"age_range_woman_older_by" toml:"age_range_woman_older_by" yaml:"age_range_woman_older_by"`
	AgeRangeManOlderBy        int               `boil:"age_range_man_older_by" json:"age_range_man_older_by" toml:"age_range_man_older_by" yaml:"age_range_man_older_by"`
	HeightMaleGreaterByCM     types.Decimal     `boil:"height_male_greater_by_cm" json:"height_male_greater_by_cm" toml:"height_male_greater_by_cm" yaml:"height_male_greater_by_cm"`
	LocationRadiusKM          types.Decimal     `boil:"location_radius_km" json:"location_radius_km" toml:"location_radius_km" yaml:"location_radius_km"`
	LocationAdaptiveExpansion types.Int64Array  `boil:"location_adaptive_expansion" json:"location_adaptive_expansion" toml:"location_adaptive_expansion" yaml:"location_adaptive_expansion"`
	MatchHours                types.StringArray `boil:"match_hours" json:"match_hours" toml:"match_hours" yaml:"match_hours"`
	DropHours                 types.StringArray `boil:"drop_hours" json:"drop_hours" toml:"drop_hours" yaml:"drop_hours"`
	DropHoursUtc              types.StringArray `boil:"drop_hours_utc" json:"drop_hours_utc" toml:"drop_hours_utc" yaml:"drop_hours_utc"`
	StaleChatNudge            int               `boil:"stale_chat_nudge" json:"stale_chat_nudge" toml:"stale_chat_nudge" yaml:"stale_chat_nudge"`
	StaleChatAgentSetup       int               `boil:"stale_chat_agent_setup" json:"stale_chat_agent_setup" toml:"stale_chat_agent_setup" yaml:"stale_chat_agent_setup"`
	MatchExpirationHours      int               `boil:"match_expiration_hours" json:"match_expiration_hours" toml:"match_expiration_hours" yaml:"match_expiration_hours"`
	MatchBlockDeclined        int               `boil:"match_block_declined" json:"match_block_declined" toml:"match_block_declined" yaml:"match_block_declined"`
	MatchBlockIgnored         int               `boil:"match_block_ignored" json:"match_block_ignored" toml:"match_block_ignored" yaml:"match_block_ignored"`
	MatchBlockClosed          int               `boil:"match_block_closed" json:"match_block_closed" toml:"match_block_closed" yaml:"match_block_closed"`
	ScoreRangeStart           types.Decimal     `boil:"score_range_start" json:"score_range_start" toml:"score_range_start" yaml:"score_range_start"`
	ScoreRangeEnd             types.Decimal     `boil:"score_range_end" json:"score_range_end" toml:"score_range_end" yaml:"score_range_end"`

	R *matchConfigR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L matchConfigL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var MatchConfigColumns = struct {
	ID                        string
	AgeRangeStart             string
	AgeRangeEnd               string
	AgeRangeWomanOlderBy      string
	AgeRangeManOlderBy        string
	HeightMaleGreaterByCM     string
	LocationRadiusKM          string
	LocationAdaptiveExpansion string
	MatchHours                string
	DropHours                 string
	DropHoursUtc              string
	StaleChatNudge            string
	StaleChatAgentSetup       string
	MatchExpirationHours      string
	MatchBlockDeclined        string
	MatchBlockIgnored         string
	MatchBlockClosed          string
	ScoreRangeStart           string
	ScoreRangeEnd             string
}{
	ID:                        "id",
	AgeRangeStart:             "age_range_start",
	AgeRangeEnd:               "age_range_end",
	AgeRangeWomanOlderBy:      "age_range_woman_older_by",
	AgeRangeManOlderBy:        "age_range_man_older_by",
	HeightMaleGreaterByCM:     "height_male_greater_by_cm",
	LocationRadiusKM:          "location_radius_km",
	LocationAdaptiveExpansion: "location_adaptive_expansion",
	MatchHours:                "match_hours",
	DropHours:                 "drop_hours",
	DropHoursUtc:              "drop_hours_utc",
	StaleChatNudge:            "stale_chat_nudge",
	StaleChatAgentSetup:       "stale_chat_agent_setup",
	MatchExpirationHours:      "match_expiration_hours",
	MatchBlockDeclined:        "match_block_declined",
	MatchBlockIgnored:         "match_block_ignored",
	MatchBlockClosed:          "match_block_closed",
	ScoreRangeStart:           "score_range_start",
	ScoreRangeEnd:             "score_range_end",
}

var MatchConfigTableColumns = struct {
	ID                        string
	AgeRangeStart             string
	AgeRangeEnd               string
	AgeRangeWomanOlderBy      string
	AgeRangeManOlderBy        string
	HeightMaleGreaterByCM     string
	LocationRadiusKM          string
	LocationAdaptiveExpansion string
	MatchHours                string
	DropHours                 string
	DropHoursUtc              string
	StaleChatNudge            string
	StaleChatAgentSetup       string
	MatchExpirationHours      string
	MatchBlockDeclined        string
	MatchBlockIgnored         string
	MatchBlockClosed          string
	ScoreRangeStart           string
	ScoreRangeEnd             string
}{
	ID:                        "match_config.id",
	AgeRangeStart:             "match_config.age_range_start",
	AgeRangeEnd:               "match_config.age_range_end",
	AgeRangeWomanOlderBy:      "match_config.age_range_woman_older_by",
	AgeRangeManOlderBy:        "match_config.age_range_man_older_by",
	HeightMaleGreaterByCM:     "match_config.height_male_greater_by_cm",
	LocationRadiusKM:          "match_config.location_radius_km",
	LocationAdaptiveExpansion: "match_config.location_adaptive_expansion",
	MatchHours:                "match_config.match_hours",
	DropHours:                 "match_config.drop_hours",
	DropHoursUtc:              "match_config.drop_hours_utc",
	StaleChatNudge:            "match_config.stale_chat_nudge",
	StaleChatAgentSetup:       "match_config.stale_chat_agent_setup",
	MatchExpirationHours:      "match_config.match_expiration_hours",
	MatchBlockDeclined:        "match_config.match_block_declined",
	MatchBlockIgnored:         "match_config.match_block_ignored",
	MatchBlockClosed:          "match_config.match_block_closed",
	ScoreRangeStart:           "match_config.score_range_start",
	ScoreRangeEnd:             "match_config.score_range_end",
}

// Generated where

type whereHelpertypes_Decimal struct{ field string }

func (w whereHelpertypes_Decimal) EQ(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertypes_Decimal) NEQ(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertypes_Decimal) LT(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_Decimal) LTE(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_Decimal) GT(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_Decimal) GTE(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpertypes_Int64Array struct{ field string }

func (w whereHelpertypes_Int64Array) EQ(x types.Int64Array) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertypes_Int64Array) NEQ(x types.Int64Array) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertypes_Int64Array) LT(x types.Int64Array) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_Int64Array) LTE(x types.Int64Array) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_Int64Array) GT(x types.Int64Array) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_Int64Array) GTE(x types.Int64Array) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpertypes_StringArray struct{ field string }

func (w whereHelpertypes_StringArray) EQ(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertypes_StringArray) NEQ(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertypes_StringArray) LT(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_StringArray) LTE(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_StringArray) GT(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_StringArray) GTE(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

var MatchConfigWhere = struct {
	ID                        whereHelperstring
	AgeRangeStart             whereHelpernull_Int
	AgeRangeEnd               whereHelpernull_Int
	AgeRangeWomanOlderBy      whereHelperint
	AgeRangeManOlderBy        whereHelperint
	HeightMaleGreaterByCM     whereHelpertypes_Decimal
	LocationRadiusKM          whereHelpertypes_Decimal
	LocationAdaptiveExpansion whereHelpertypes_Int64Array
	MatchHours                whereHelpertypes_StringArray
	DropHours                 whereHelpertypes_StringArray
	DropHoursUtc              whereHelpertypes_StringArray
	StaleChatNudge            whereHelperint
	StaleChatAgentSetup       whereHelperint
	MatchExpirationHours      whereHelperint
	MatchBlockDeclined        whereHelperint
	MatchBlockIgnored         whereHelperint
	MatchBlockClosed          whereHelperint
	ScoreRangeStart           whereHelpertypes_Decimal
	ScoreRangeEnd             whereHelpertypes_Decimal
}{
	ID:                        whereHelperstring{field: "\"match_config\".\"id\""},
	AgeRangeStart:             whereHelpernull_Int{field: "\"match_config\".\"age_range_start\""},
	AgeRangeEnd:               whereHelpernull_Int{field: "\"match_config\".\"age_range_end\""},
	AgeRangeWomanOlderBy:      whereHelperint{field: "\"match_config\".\"age_range_woman_older_by\""},
	AgeRangeManOlderBy:        whereHelperint{field: "\"match_config\".\"age_range_man_older_by\""},
	HeightMaleGreaterByCM:     whereHelpertypes_Decimal{field: "\"match_config\".\"height_male_greater_by_cm\""},
	LocationRadiusKM:          whereHelpertypes_Decimal{field: "\"match_config\".\"location_radius_km\""},
	LocationAdaptiveExpansion: whereHelpertypes_Int64Array{field: "\"match_config\".\"location_adaptive_expansion\""},
	MatchHours:                whereHelpertypes_StringArray{field: "\"match_config\".\"match_hours\""},
	DropHours:                 whereHelpertypes_StringArray{field: "\"match_config\".\"drop_hours\""},
	DropHoursUtc:              whereHelpertypes_StringArray{field: "\"match_config\".\"drop_hours_utc\""},
	StaleChatNudge:            whereHelperint{field: "\"match_config\".\"stale_chat_nudge\""},
	StaleChatAgentSetup:       whereHelperint{field: "\"match_config\".\"stale_chat_agent_setup\""},
	MatchExpirationHours:      whereHelperint{field: "\"match_config\".\"match_expiration_hours\""},
	MatchBlockDeclined:        whereHelperint{field: "\"match_config\".\"match_block_declined\""},
	MatchBlockIgnored:         whereHelperint{field: "\"match_config\".\"match_block_ignored\""},
	MatchBlockClosed:          whereHelperint{field: "\"match_config\".\"match_block_closed\""},
	ScoreRangeStart:           whereHelpertypes_Decimal{field: "\"match_config\".\"score_range_start\""},
	ScoreRangeEnd:             whereHelpertypes_Decimal{field: "\"match_config\".\"score_range_end\""},
}

// MatchConfigRels is where relationship names are stored.
var MatchConfigRels = struct {
}{}

// matchConfigR is where relationships are stored.
type matchConfigR struct {
}

// NewStruct creates a new relationship struct
func (*matchConfigR) NewStruct() *matchConfigR {
	return &matchConfigR{}
}

// matchConfigL is where Load methods for each relationship are stored.
type matchConfigL struct{}

var (
	matchConfigAllColumns            = []string{"id", "age_range_start", "age_range_end", "age_range_woman_older_by", "age_range_man_older_by", "height_male_greater_by_cm", "location_radius_km", "location_adaptive_expansion", "match_hours", "drop_hours", "drop_hours_utc", "stale_chat_nudge", "stale_chat_agent_setup", "match_expiration_hours", "match_block_declined", "match_block_ignored", "match_block_closed", "score_range_start", "score_range_end"}
	matchConfigColumnsWithoutDefault = []string{}
	matchConfigColumnsWithDefault    = []string{"id", "age_range_start", "age_range_end", "age_range_woman_older_by", "age_range_man_older_by", "height_male_greater_by_cm", "location_radius_km", "location_adaptive_expansion", "match_hours", "drop_hours", "drop_hours_utc", "stale_chat_nudge", "stale_chat_agent_setup", "match_expiration_hours", "match_block_declined", "match_block_ignored", "match_block_closed", "score_range_start", "score_range_end"}
	matchConfigPrimaryKeyColumns     = []string{"id"}
	matchConfigGeneratedColumns      = []string{}
)

type (
	// MatchConfigSlice is an alias for a slice of pointers to MatchConfig.
	// This should almost always be used instead of []MatchConfig.
	MatchConfigSlice []*MatchConfig
	// MatchConfigHook is the signature for custom MatchConfig hook methods
	MatchConfigHook func(context.Context, boil.ContextExecutor, *MatchConfig) error

	matchConfigQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	matchConfigType                 = reflect.TypeOf(&MatchConfig{})
	matchConfigMapping              = queries.MakeStructMapping(matchConfigType)
	matchConfigPrimaryKeyMapping, _ = queries.BindMapping(matchConfigType, matchConfigMapping, matchConfigPrimaryKeyColumns)
	matchConfigInsertCacheMut       sync.RWMutex
	matchConfigInsertCache          = make(map[string]insertCache)
	matchConfigUpdateCacheMut       sync.RWMutex
	matchConfigUpdateCache          = make(map[string]updateCache)
	matchConfigUpsertCacheMut       sync.RWMutex
	matchConfigUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var matchConfigAfterSelectMu sync.Mutex
var matchConfigAfterSelectHooks []MatchConfigHook

var matchConfigBeforeInsertMu sync.Mutex
var matchConfigBeforeInsertHooks []MatchConfigHook
var matchConfigAfterInsertMu sync.Mutex
var matchConfigAfterInsertHooks []MatchConfigHook

var matchConfigBeforeUpdateMu sync.Mutex
var matchConfigBeforeUpdateHooks []MatchConfigHook
var matchConfigAfterUpdateMu sync.Mutex
var matchConfigAfterUpdateHooks []MatchConfigHook

var matchConfigBeforeDeleteMu sync.Mutex
var matchConfigBeforeDeleteHooks []MatchConfigHook
var matchConfigAfterDeleteMu sync.Mutex
var matchConfigAfterDeleteHooks []MatchConfigHook

var matchConfigBeforeUpsertMu sync.Mutex
var matchConfigBeforeUpsertHooks []MatchConfigHook
var matchConfigAfterUpsertMu sync.Mutex
var matchConfigAfterUpsertHooks []MatchConfigHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *MatchConfig) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range matchConfigAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *MatchConfig) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range matchConfigBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *MatchConfig) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range matchConfigAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *MatchConfig) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range matchConfigBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *MatchConfig) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range matchConfigAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *MatchConfig) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range matchConfigBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *MatchConfig) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range matchConfigAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *MatchConfig) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range matchConfigBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *MatchConfig) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range matchConfigAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddMatchConfigHook registers your hook function for all future operations.
func AddMatchConfigHook(hookPoint boil.HookPoint, matchConfigHook MatchConfigHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		matchConfigAfterSelectMu.Lock()
		matchConfigAfterSelectHooks = append(matchConfigAfterSelectHooks, matchConfigHook)
		matchConfigAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		matchConfigBeforeInsertMu.Lock()
		matchConfigBeforeInsertHooks = append(matchConfigBeforeInsertHooks, matchConfigHook)
		matchConfigBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		matchConfigAfterInsertMu.Lock()
		matchConfigAfterInsertHooks = append(matchConfigAfterInsertHooks, matchConfigHook)
		matchConfigAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		matchConfigBeforeUpdateMu.Lock()
		matchConfigBeforeUpdateHooks = append(matchConfigBeforeUpdateHooks, matchConfigHook)
		matchConfigBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		matchConfigAfterUpdateMu.Lock()
		matchConfigAfterUpdateHooks = append(matchConfigAfterUpdateHooks, matchConfigHook)
		matchConfigAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		matchConfigBeforeDeleteMu.Lock()
		matchConfigBeforeDeleteHooks = append(matchConfigBeforeDeleteHooks, matchConfigHook)
		matchConfigBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		matchConfigAfterDeleteMu.Lock()
		matchConfigAfterDeleteHooks = append(matchConfigAfterDeleteHooks, matchConfigHook)
		matchConfigAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		matchConfigBeforeUpsertMu.Lock()
		matchConfigBeforeUpsertHooks = append(matchConfigBeforeUpsertHooks, matchConfigHook)
		matchConfigBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		matchConfigAfterUpsertMu.Lock()
		matchConfigAfterUpsertHooks = append(matchConfigAfterUpsertHooks, matchConfigHook)
		matchConfigAfterUpsertMu.Unlock()
	}
}

// One returns a single matchConfig record from the query.
func (q matchConfigQuery) One(ctx context.Context, exec boil.ContextExecutor) (*MatchConfig, error) {
	o := &MatchConfig{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "pgmodel: failed to execute a one query for match_config")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all MatchConfig records from the query.
func (q matchConfigQuery) All(ctx context.Context, exec boil.ContextExecutor) (MatchConfigSlice, error) {
	var o []*MatchConfig

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "pgmodel: failed to assign all query results to MatchConfig slice")
	}

	if len(matchConfigAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all MatchConfig records in the query.
func (q matchConfigQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: failed to count match_config rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q matchConfigQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "pgmodel: failed to check if match_config exists")
	}

	return count > 0, nil
}

// MatchConfigs retrieves all the records using an executor.
func MatchConfigs(mods ...qm.QueryMod) matchConfigQuery {
	mods = append(mods, qm.From("\"match_config\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"match_config\".*"})
	}

	return matchConfigQuery{q}
}

// FindMatchConfig retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindMatchConfig(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*MatchConfig, error) {
	matchConfigObj := &MatchConfig{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"match_config\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, matchConfigObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "pgmodel: unable to select from match_config")
	}

	if err = matchConfigObj.doAfterSelectHooks(ctx, exec); err != nil {
		return matchConfigObj, err
	}

	return matchConfigObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *MatchConfig) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("pgmodel: no match_config provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(matchConfigColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	matchConfigInsertCacheMut.RLock()
	cache, cached := matchConfigInsertCache[key]
	matchConfigInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			matchConfigAllColumns,
			matchConfigColumnsWithDefault,
			matchConfigColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(matchConfigType, matchConfigMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(matchConfigType, matchConfigMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"match_config\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"match_config\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "pgmodel: unable to insert into match_config")
	}

	if !cached {
		matchConfigInsertCacheMut.Lock()
		matchConfigInsertCache[key] = cache
		matchConfigInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the MatchConfig.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *MatchConfig) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	matchConfigUpdateCacheMut.RLock()
	cache, cached := matchConfigUpdateCache[key]
	matchConfigUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			matchConfigAllColumns,
			matchConfigPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("pgmodel: unable to update match_config, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"match_config\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, matchConfigPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(matchConfigType, matchConfigMapping, append(wl, matchConfigPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to update match_config row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: failed to get rows affected by update for match_config")
	}

	if !cached {
		matchConfigUpdateCacheMut.Lock()
		matchConfigUpdateCache[key] = cache
		matchConfigUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q matchConfigQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to update all for match_config")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to retrieve rows affected for match_config")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o MatchConfigSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("pgmodel: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), matchConfigPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"match_config\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, matchConfigPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to update all in matchConfig slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to retrieve rows affected all in update all matchConfig")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *MatchConfig) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("pgmodel: no match_config provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(matchConfigColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	matchConfigUpsertCacheMut.RLock()
	cache, cached := matchConfigUpsertCache[key]
	matchConfigUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			matchConfigAllColumns,
			matchConfigColumnsWithDefault,
			matchConfigColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			matchConfigAllColumns,
			matchConfigPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("pgmodel: unable to upsert match_config, could not build update column list")
		}

		ret := strmangle.SetComplement(matchConfigAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(matchConfigPrimaryKeyColumns) == 0 {
				return errors.New("pgmodel: unable to upsert match_config, could not build conflict column list")
			}

			conflict = make([]string, len(matchConfigPrimaryKeyColumns))
			copy(conflict, matchConfigPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"match_config\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(matchConfigType, matchConfigMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(matchConfigType, matchConfigMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "pgmodel: unable to upsert match_config")
	}

	if !cached {
		matchConfigUpsertCacheMut.Lock()
		matchConfigUpsertCache[key] = cache
		matchConfigUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single MatchConfig record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *MatchConfig) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("pgmodel: no MatchConfig provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), matchConfigPrimaryKeyMapping)
	sql := "DELETE FROM \"match_config\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to delete from match_config")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: failed to get rows affected by delete for match_config")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q matchConfigQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("pgmodel: no matchConfigQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to delete all from match_config")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: failed to get rows affected by deleteall for match_config")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o MatchConfigSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(matchConfigBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), matchConfigPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"match_config\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, matchConfigPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to delete all from matchConfig slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: failed to get rows affected by deleteall for match_config")
	}

	if len(matchConfigAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *MatchConfig) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindMatchConfig(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *MatchConfigSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := MatchConfigSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), matchConfigPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"match_config\".* FROM \"match_config\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, matchConfigPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "pgmodel: unable to reload all in MatchConfigSlice")
	}

	*o = slice

	return nil
}

// MatchConfigExists checks if the MatchConfig row exists.
func MatchConfigExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"match_config\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "pgmodel: unable to check if match_config exists")
	}

	return exists, nil
}

// Exists checks if the MatchConfig row exists.
func (o *MatchConfig) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return MatchConfigExists(ctx, exec, o.ID)
}
