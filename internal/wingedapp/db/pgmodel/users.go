// Code generated by SQLBoiler 4.19.5 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package pgmodel

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// User is an object representing the database table.
type User struct {
	ID                      string       `boil:"id" json:"id" toml:"id" yaml:"id"`
	SupabaseID              null.String  `boil:"supabase_id" json:"supabase_id,omitempty" toml:"supabase_id" yaml:"supabase_id,omitempty"`
	FirstName               null.String  `boil:"first_name" json:"first_name,omitempty" toml:"first_name" yaml:"first_name,omitempty"`
	LastName                null.String  `boil:"last_name" json:"last_name,omitempty" toml:"last_name" yaml:"last_name,omitempty"`
	Email                   string       `boil:"email" json:"email" toml:"email" yaml:"email"`
	Password                null.String  `boil:"password" json:"password,omitempty" toml:"password" yaml:"password,omitempty"`
	Address                 null.String  `boil:"address" json:"address,omitempty" toml:"address" yaml:"address,omitempty"`
	MobileNumber            null.String  `boil:"mobile_number" json:"mobile_number,omitempty" toml:"mobile_number" yaml:"mobile_number,omitempty"`
	Birthday                null.Time    `boil:"birthday" json:"birthday,omitempty" toml:"birthday" yaml:"birthday,omitempty"`
	Gender                  null.String  `boil:"gender" json:"gender,omitempty" toml:"gender" yaml:"gender,omitempty"`
	HeightCM                null.Int     `boil:"height_cm" json:"height_cm,omitempty" toml:"height_cm" yaml:"height_cm,omitempty"`
	Location                null.String  `boil:"location" json:"location,omitempty" toml:"location" yaml:"location,omitempty"`
	DatingPrefAgeRangeStart null.Int     `boil:"dating_pref_age_range_start" json:"dating_pref_age_range_start,omitempty" toml:"dating_pref_age_range_start" yaml:"dating_pref_age_range_start,omitempty"`
	DatingPrefAgeRangeEnd   null.Int     `boil:"dating_pref_age_range_end" json:"dating_pref_age_range_end,omitempty" toml:"dating_pref_age_range_end" yaml:"dating_pref_age_range_end,omitempty"`
	AgentDating             null.Bool    `boil:"agent_dating" json:"agent_dating,omitempty" toml:"agent_dating" yaml:"agent_dating,omitempty"`
	ResetToken              null.String  `boil:"reset_token" json:"reset_token,omitempty" toml:"reset_token" yaml:"reset_token,omitempty"`
	RegistrationCode        null.String  `boil:"registration_code" json:"registration_code,omitempty" toml:"registration_code" yaml:"registration_code,omitempty"`
	RegistrationCodeSentAt  null.Time    `boil:"registration_code_sent_at" json:"registration_code_sent_at,omitempty" toml:"registration_code_sent_at" yaml:"registration_code_sent_at,omitempty"`
	LastCheckedCallStatus   null.Time    `boil:"last_checked_call_status" json:"last_checked_call_status,omitempty" toml:"last_checked_call_status" yaml:"last_checked_call_status,omitempty"`
	AgentDeployed           null.Bool    `boil:"agent_deployed" json:"agent_deployed,omitempty" toml:"agent_deployed" yaml:"agent_deployed,omitempty"`
	SelectedIntroID         null.String  `boil:"selected_intro_id" json:"selected_intro_id,omitempty" toml:"selected_intro_id" yaml:"selected_intro_id,omitempty"`
	RegisteredSuccessfully  null.Bool    `boil:"registered_successfully" json:"registered_successfully,omitempty" toml:"registered_successfully" yaml:"registered_successfully,omitempty"`
	MobileCode              null.String  `boil:"mobile_code" json:"mobile_code,omitempty" toml:"mobile_code" yaml:"mobile_code,omitempty"`
	Sha256Hash              null.String  `boil:"sha256_hash" json:"sha256_hash,omitempty" toml:"sha256_hash" yaml:"sha256_hash,omitempty"`
	MobileConfirmed         null.Bool    `boil:"mobile_confirmed" json:"mobile_confirmed,omitempty" toml:"mobile_confirmed" yaml:"mobile_confirmed,omitempty"`
	UserInviteCodeRefID     null.String  `boil:"user_invite_code_ref_id" json:"user_invite_code_ref_id,omitempty" toml:"user_invite_code_ref_id" yaml:"user_invite_code_ref_id,omitempty"`
	CreatedBy               null.String  `boil:"created_by" json:"created_by,omitempty" toml:"created_by" yaml:"created_by,omitempty"`
	LatestTranscriptID      null.String  `boil:"latest_transcript_id" json:"latest_transcript_id,omitempty" toml:"latest_transcript_id" yaml:"latest_transcript_id,omitempty"`
	LatestTranscriptTS      null.Time    `boil:"latest_transcript_ts" json:"latest_transcript_ts,omitempty" toml:"latest_transcript_ts" yaml:"latest_transcript_ts,omitempty"`
	HasTranscript           bool         `boil:"has_transcript" json:"has_transcript" toml:"has_transcript" yaml:"has_transcript"`
	Latitude                null.Float64 `boil:"latitude" json:"latitude,omitempty" toml:"latitude" yaml:"latitude,omitempty"`
	Longitude               null.Float64 `boil:"longitude" json:"longitude,omitempty" toml:"longitude" yaml:"longitude,omitempty"`
	IdealFirstDatePhrase    null.String  `boil:"ideal_first_date_phrase" json:"ideal_first_date_phrase,omitempty" toml:"ideal_first_date_phrase" yaml:"ideal_first_date_phrase,omitempty"`
	DateTypeBucket          null.String  `boil:"date_type_bucket" json:"date_type_bucket,omitempty" toml:"date_type_bucket" yaml:"date_type_bucket,omitempty"`
	DateTypeSubtype         null.String  `boil:"date_type_subtype" json:"date_type_subtype,omitempty" toml:"date_type_subtype" yaml:"date_type_subtype,omitempty"`
	UserType                string       `boil:"user_type" json:"user_type" toml:"user_type" yaml:"user_type"`
	Sexuality               null.String  `boil:"sexuality" json:"sexuality,omitempty" toml:"sexuality" yaml:"sexuality,omitempty"`
	SexualityIsVisible      null.Bool    `boil:"sexuality_is_visible" json:"sexuality_is_visible,omitempty" toml:"sexuality_is_visible" yaml:"sexuality_is_visible,omitempty"`
	LastUpdatedBy           null.String  `boil:"last_updated_by" json:"last_updated_by,omitempty" toml:"last_updated_by" yaml:"last_updated_by,omitempty"`
	CreatedAt               null.Time    `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
	UpdatedAt               null.Time    `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	IsActive                null.Bool    `boil:"is_active" json:"is_active,omitempty" toml:"is_active" yaml:"is_active,omitempty"`
	IsTestUser              null.Bool    `boil:"is_test_user" json:"is_test_user,omitempty" toml:"is_test_user" yaml:"is_test_user,omitempty"`

	R *userR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L userL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var UserColumns = struct {
	ID                      string
	SupabaseID              string
	FirstName               string
	LastName                string
	Email                   string
	Password                string
	Address                 string
	MobileNumber            string
	Birthday                string
	Gender                  string
	HeightCM                string
	Location                string
	DatingPrefAgeRangeStart string
	DatingPrefAgeRangeEnd   string
	AgentDating             string
	ResetToken              string
	RegistrationCode        string
	RegistrationCodeSentAt  string
	LastCheckedCallStatus   string
	AgentDeployed           string
	SelectedIntroID         string
	RegisteredSuccessfully  string
	MobileCode              string
	Sha256Hash              string
	MobileConfirmed         string
	UserInviteCodeRefID     string
	CreatedBy               string
	LatestTranscriptID      string
	LatestTranscriptTS      string
	HasTranscript           string
	Latitude                string
	Longitude               string
	IdealFirstDatePhrase    string
	DateTypeBucket          string
	DateTypeSubtype         string
	UserType                string
	Sexuality               string
	SexualityIsVisible      string
	LastUpdatedBy           string
	CreatedAt               string
	UpdatedAt               string
	IsActive                string
	IsTestUser              string
}{
	ID:                      "id",
	SupabaseID:              "supabase_id",
	FirstName:               "first_name",
	LastName:                "last_name",
	Email:                   "email",
	Password:                "password",
	Address:                 "address",
	MobileNumber:            "mobile_number",
	Birthday:                "birthday",
	Gender:                  "gender",
	HeightCM:                "height_cm",
	Location:                "location",
	DatingPrefAgeRangeStart: "dating_pref_age_range_start",
	DatingPrefAgeRangeEnd:   "dating_pref_age_range_end",
	AgentDating:             "agent_dating",
	ResetToken:              "reset_token",
	RegistrationCode:        "registration_code",
	RegistrationCodeSentAt:  "registration_code_sent_at",
	LastCheckedCallStatus:   "last_checked_call_status",
	AgentDeployed:           "agent_deployed",
	SelectedIntroID:         "selected_intro_id",
	RegisteredSuccessfully:  "registered_successfully",
	MobileCode:              "mobile_code",
	Sha256Hash:              "sha256_hash",
	MobileConfirmed:         "mobile_confirmed",
	UserInviteCodeRefID:     "user_invite_code_ref_id",
	CreatedBy:               "created_by",
	LatestTranscriptID:      "latest_transcript_id",
	LatestTranscriptTS:      "latest_transcript_ts",
	HasTranscript:           "has_transcript",
	Latitude:                "latitude",
	Longitude:               "longitude",
	IdealFirstDatePhrase:    "ideal_first_date_phrase",
	DateTypeBucket:          "date_type_bucket",
	DateTypeSubtype:         "date_type_subtype",
	UserType:                "user_type",
	Sexuality:               "sexuality",
	SexualityIsVisible:      "sexuality_is_visible",
	LastUpdatedBy:           "last_updated_by",
	CreatedAt:               "created_at",
	UpdatedAt:               "updated_at",
	IsActive:                "is_active",
	IsTestUser:              "is_test_user",
}

var UserTableColumns = struct {
	ID                      string
	SupabaseID              string
	FirstName               string
	LastName                string
	Email                   string
	Password                string
	Address                 string
	MobileNumber            string
	Birthday                string
	Gender                  string
	HeightCM                string
	Location                string
	DatingPrefAgeRangeStart string
	DatingPrefAgeRangeEnd   string
	AgentDating             string
	ResetToken              string
	RegistrationCode        string
	RegistrationCodeSentAt  string
	LastCheckedCallStatus   string
	AgentDeployed           string
	SelectedIntroID         string
	RegisteredSuccessfully  string
	MobileCode              string
	Sha256Hash              string
	MobileConfirmed         string
	UserInviteCodeRefID     string
	CreatedBy               string
	LatestTranscriptID      string
	LatestTranscriptTS      string
	HasTranscript           string
	Latitude                string
	Longitude               string
	IdealFirstDatePhrase    string
	DateTypeBucket          string
	DateTypeSubtype         string
	UserType                string
	Sexuality               string
	SexualityIsVisible      string
	LastUpdatedBy           string
	CreatedAt               string
	UpdatedAt               string
	IsActive                string
	IsTestUser              string
}{
	ID:                      "users.id",
	SupabaseID:              "users.supabase_id",
	FirstName:               "users.first_name",
	LastName:                "users.last_name",
	Email:                   "users.email",
	Password:                "users.password",
	Address:                 "users.address",
	MobileNumber:            "users.mobile_number",
	Birthday:                "users.birthday",
	Gender:                  "users.gender",
	HeightCM:                "users.height_cm",
	Location:                "users.location",
	DatingPrefAgeRangeStart: "users.dating_pref_age_range_start",
	DatingPrefAgeRangeEnd:   "users.dating_pref_age_range_end",
	AgentDating:             "users.agent_dating",
	ResetToken:              "users.reset_token",
	RegistrationCode:        "users.registration_code",
	RegistrationCodeSentAt:  "users.registration_code_sent_at",
	LastCheckedCallStatus:   "users.last_checked_call_status",
	AgentDeployed:           "users.agent_deployed",
	SelectedIntroID:         "users.selected_intro_id",
	RegisteredSuccessfully:  "users.registered_successfully",
	MobileCode:              "users.mobile_code",
	Sha256Hash:              "users.sha256_hash",
	MobileConfirmed:         "users.mobile_confirmed",
	UserInviteCodeRefID:     "users.user_invite_code_ref_id",
	CreatedBy:               "users.created_by",
	LatestTranscriptID:      "users.latest_transcript_id",
	LatestTranscriptTS:      "users.latest_transcript_ts",
	HasTranscript:           "users.has_transcript",
	Latitude:                "users.latitude",
	Longitude:               "users.longitude",
	IdealFirstDatePhrase:    "users.ideal_first_date_phrase",
	DateTypeBucket:          "users.date_type_bucket",
	DateTypeSubtype:         "users.date_type_subtype",
	UserType:                "users.user_type",
	Sexuality:               "users.sexuality",
	SexualityIsVisible:      "users.sexuality_is_visible",
	LastUpdatedBy:           "users.last_updated_by",
	CreatedAt:               "users.created_at",
	UpdatedAt:               "users.updated_at",
	IsActive:                "users.is_active",
	IsTestUser:              "users.is_test_user",
}

// Generated where

type whereHelpernull_Float64 struct{ field string }

func (w whereHelpernull_Float64) EQ(x null.Float64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Float64) NEQ(x null.Float64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Float64) LT(x null.Float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Float64) LTE(x null.Float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Float64) GT(x null.Float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Float64) GTE(x null.Float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Float64) IN(slice []float64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Float64) NIN(slice []float64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Float64) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Float64) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var UserWhere = struct {
	ID                      whereHelperstring
	SupabaseID              whereHelpernull_String
	FirstName               whereHelpernull_String
	LastName                whereHelpernull_String
	Email                   whereHelperstring
	Password                whereHelpernull_String
	Address                 whereHelpernull_String
	MobileNumber            whereHelpernull_String
	Birthday                whereHelpernull_Time
	Gender                  whereHelpernull_String
	HeightCM                whereHelpernull_Int
	Location                whereHelpernull_String
	DatingPrefAgeRangeStart whereHelpernull_Int
	DatingPrefAgeRangeEnd   whereHelpernull_Int
	AgentDating             whereHelpernull_Bool
	ResetToken              whereHelpernull_String
	RegistrationCode        whereHelpernull_String
	RegistrationCodeSentAt  whereHelpernull_Time
	LastCheckedCallStatus   whereHelpernull_Time
	AgentDeployed           whereHelpernull_Bool
	SelectedIntroID         whereHelpernull_String
	RegisteredSuccessfully  whereHelpernull_Bool
	MobileCode              whereHelpernull_String
	Sha256Hash              whereHelpernull_String
	MobileConfirmed         whereHelpernull_Bool
	UserInviteCodeRefID     whereHelpernull_String
	CreatedBy               whereHelpernull_String
	LatestTranscriptID      whereHelpernull_String
	LatestTranscriptTS      whereHelpernull_Time
	HasTranscript           whereHelperbool
	Latitude                whereHelpernull_Float64
	Longitude               whereHelpernull_Float64
	IdealFirstDatePhrase    whereHelpernull_String
	DateTypeBucket          whereHelpernull_String
	DateTypeSubtype         whereHelpernull_String
	UserType                whereHelperstring
	Sexuality               whereHelpernull_String
	SexualityIsVisible      whereHelpernull_Bool
	LastUpdatedBy           whereHelpernull_String
	CreatedAt               whereHelpernull_Time
	UpdatedAt               whereHelpernull_Time
	IsActive                whereHelpernull_Bool
	IsTestUser              whereHelpernull_Bool
}{
	ID:                      whereHelperstring{field: "\"users\".\"id\""},
	SupabaseID:              whereHelpernull_String{field: "\"users\".\"supabase_id\""},
	FirstName:               whereHelpernull_String{field: "\"users\".\"first_name\""},
	LastName:                whereHelpernull_String{field: "\"users\".\"last_name\""},
	Email:                   whereHelperstring{field: "\"users\".\"email\""},
	Password:                whereHelpernull_String{field: "\"users\".\"password\""},
	Address:                 whereHelpernull_String{field: "\"users\".\"address\""},
	MobileNumber:            whereHelpernull_String{field: "\"users\".\"mobile_number\""},
	Birthday:                whereHelpernull_Time{field: "\"users\".\"birthday\""},
	Gender:                  whereHelpernull_String{field: "\"users\".\"gender\""},
	HeightCM:                whereHelpernull_Int{field: "\"users\".\"height_cm\""},
	Location:                whereHelpernull_String{field: "\"users\".\"location\""},
	DatingPrefAgeRangeStart: whereHelpernull_Int{field: "\"users\".\"dating_pref_age_range_start\""},
	DatingPrefAgeRangeEnd:   whereHelpernull_Int{field: "\"users\".\"dating_pref_age_range_end\""},
	AgentDating:             whereHelpernull_Bool{field: "\"users\".\"agent_dating\""},
	ResetToken:              whereHelpernull_String{field: "\"users\".\"reset_token\""},
	RegistrationCode:        whereHelpernull_String{field: "\"users\".\"registration_code\""},
	RegistrationCodeSentAt:  whereHelpernull_Time{field: "\"users\".\"registration_code_sent_at\""},
	LastCheckedCallStatus:   whereHelpernull_Time{field: "\"users\".\"last_checked_call_status\""},
	AgentDeployed:           whereHelpernull_Bool{field: "\"users\".\"agent_deployed\""},
	SelectedIntroID:         whereHelpernull_String{field: "\"users\".\"selected_intro_id\""},
	RegisteredSuccessfully:  whereHelpernull_Bool{field: "\"users\".\"registered_successfully\""},
	MobileCode:              whereHelpernull_String{field: "\"users\".\"mobile_code\""},
	Sha256Hash:              whereHelpernull_String{field: "\"users\".\"sha256_hash\""},
	MobileConfirmed:         whereHelpernull_Bool{field: "\"users\".\"mobile_confirmed\""},
	UserInviteCodeRefID:     whereHelpernull_String{field: "\"users\".\"user_invite_code_ref_id\""},
	CreatedBy:               whereHelpernull_String{field: "\"users\".\"created_by\""},
	LatestTranscriptID:      whereHelpernull_String{field: "\"users\".\"latest_transcript_id\""},
	LatestTranscriptTS:      whereHelpernull_Time{field: "\"users\".\"latest_transcript_ts\""},
	HasTranscript:           whereHelperbool{field: "\"users\".\"has_transcript\""},
	Latitude:                whereHelpernull_Float64{field: "\"users\".\"latitude\""},
	Longitude:               whereHelpernull_Float64{field: "\"users\".\"longitude\""},
	IdealFirstDatePhrase:    whereHelpernull_String{field: "\"users\".\"ideal_first_date_phrase\""},
	DateTypeBucket:          whereHelpernull_String{field: "\"users\".\"date_type_bucket\""},
	DateTypeSubtype:         whereHelpernull_String{field: "\"users\".\"date_type_subtype\""},
	UserType:                whereHelperstring{field: "\"users\".\"user_type\""},
	Sexuality:               whereHelpernull_String{field: "\"users\".\"sexuality\""},
	SexualityIsVisible:      whereHelpernull_Bool{field: "\"users\".\"sexuality_is_visible\""},
	LastUpdatedBy:           whereHelpernull_String{field: "\"users\".\"last_updated_by\""},
	CreatedAt:               whereHelpernull_Time{field: "\"users\".\"created_at\""},
	UpdatedAt:               whereHelpernull_Time{field: "\"users\".\"updated_at\""},
	IsActive:                whereHelpernull_Bool{field: "\"users\".\"is_active\""},
	IsTestUser:              whereHelpernull_Bool{field: "\"users\".\"is_test_user\""},
}

// UserRels is where relationship names are stored.
var UserRels = struct {
	CreatedByUser                       string
	LastUpdatedByUser                   string
	UserInviteCodeRef                   string
	UserRefWingsEcnUserTotal            string
	UserRefAgentLogs                    string
	UserRefDateInstanceLogs             string
	SuggestedByRefDateInstanceProposals string
	SenderMatchChatMessages             string
	InitiatorUserRefMatchResults        string
	ReceiverUserRefMatchResults         string
	UserARefMatchResults                string
	UserBRefMatchResults                string
	UserRefNotifications                string
	UserRefSchedulingCards              string
	UserAiContexts                      string
	UserAiConvos                        string
	UserAvailabilities                  string
	UserBlockedContacts                 string
	UserDateTypePreferences             string
	UserDatingPreferences               string
	UserDietaryRestrictions             string
	UserElevenLabs                      string
	UserMobilityConstraints             string
	UserPhotos                          string
	CreatedByUsers                      string
	LastUpdatedByUsers                  string
	SuggestedByRefVenueSuggestions      string
	UserRefWingsEcnActionLogs           string
	WingsEcnUserSubscriptionPlans       string
}{
	CreatedByUser:                       "CreatedByUser",
	LastUpdatedByUser:                   "LastUpdatedByUser",
	UserInviteCodeRef:                   "UserInviteCodeRef",
	UserRefWingsEcnUserTotal:            "UserRefWingsEcnUserTotal",
	UserRefAgentLogs:                    "UserRefAgentLogs",
	UserRefDateInstanceLogs:             "UserRefDateInstanceLogs",
	SuggestedByRefDateInstanceProposals: "SuggestedByRefDateInstanceProposals",
	SenderMatchChatMessages:             "SenderMatchChatMessages",
	InitiatorUserRefMatchResults:        "InitiatorUserRefMatchResults",
	ReceiverUserRefMatchResults:         "ReceiverUserRefMatchResults",
	UserARefMatchResults:                "UserARefMatchResults",
	UserBRefMatchResults:                "UserBRefMatchResults",
	UserRefNotifications:                "UserRefNotifications",
	UserRefSchedulingCards:              "UserRefSchedulingCards",
	UserAiContexts:                      "UserAiContexts",
	UserAiConvos:                        "UserAiConvos",
	UserAvailabilities:                  "UserAvailabilities",
	UserBlockedContacts:                 "UserBlockedContacts",
	UserDateTypePreferences:             "UserDateTypePreferences",
	UserDatingPreferences:               "UserDatingPreferences",
	UserDietaryRestrictions:             "UserDietaryRestrictions",
	UserElevenLabs:                      "UserElevenLabs",
	UserMobilityConstraints:             "UserMobilityConstraints",
	UserPhotos:                          "UserPhotos",
	CreatedByUsers:                      "CreatedByUsers",
	LastUpdatedByUsers:                  "LastUpdatedByUsers",
	SuggestedByRefVenueSuggestions:      "SuggestedByRefVenueSuggestions",
	UserRefWingsEcnActionLogs:           "UserRefWingsEcnActionLogs",
	WingsEcnUserSubscriptionPlans:       "WingsEcnUserSubscriptionPlans",
}

// userR is where relationships are stored.
type userR struct {
	CreatedByUser                       *User                             `boil:"CreatedByUser" json:"CreatedByUser" toml:"CreatedByUser" yaml:"CreatedByUser"`
	LastUpdatedByUser                   *User                             `boil:"LastUpdatedByUser" json:"LastUpdatedByUser" toml:"LastUpdatedByUser" yaml:"LastUpdatedByUser"`
	UserInviteCodeRef                   *UserInviteCode                   `boil:"UserInviteCodeRef" json:"UserInviteCodeRef" toml:"UserInviteCodeRef" yaml:"UserInviteCodeRef"`
	UserRefWingsEcnUserTotal            *WingsEcnUserTotal                `boil:"UserRefWingsEcnUserTotal" json:"UserRefWingsEcnUserTotal" toml:"UserRefWingsEcnUserTotal" yaml:"UserRefWingsEcnUserTotal"`
	UserRefAgentLogs                    AgentLogSlice                     `boil:"UserRefAgentLogs" json:"UserRefAgentLogs" toml:"UserRefAgentLogs" yaml:"UserRefAgentLogs"`
	UserRefDateInstanceLogs             DateInstanceLogSlice              `boil:"UserRefDateInstanceLogs" json:"UserRefDateInstanceLogs" toml:"UserRefDateInstanceLogs" yaml:"UserRefDateInstanceLogs"`
	SuggestedByRefDateInstanceProposals DateInstanceProposalSlice         `boil:"SuggestedByRefDateInstanceProposals" json:"SuggestedByRefDateInstanceProposals" toml:"SuggestedByRefDateInstanceProposals" yaml:"SuggestedByRefDateInstanceProposals"`
	SenderMatchChatMessages             MatchChatMessageSlice             `boil:"SenderMatchChatMessages" json:"SenderMatchChatMessages" toml:"SenderMatchChatMessages" yaml:"SenderMatchChatMessages"`
	InitiatorUserRefMatchResults        MatchResultSlice                  `boil:"InitiatorUserRefMatchResults" json:"InitiatorUserRefMatchResults" toml:"InitiatorUserRefMatchResults" yaml:"InitiatorUserRefMatchResults"`
	ReceiverUserRefMatchResults         MatchResultSlice                  `boil:"ReceiverUserRefMatchResults" json:"ReceiverUserRefMatchResults" toml:"ReceiverUserRefMatchResults" yaml:"ReceiverUserRefMatchResults"`
	UserARefMatchResults                MatchResultSlice                  `boil:"UserARefMatchResults" json:"UserARefMatchResults" toml:"UserARefMatchResults" yaml:"UserARefMatchResults"`
	UserBRefMatchResults                MatchResultSlice                  `boil:"UserBRefMatchResults" json:"UserBRefMatchResults" toml:"UserBRefMatchResults" yaml:"UserBRefMatchResults"`
	UserRefNotifications                NotificationSlice                 `boil:"UserRefNotifications" json:"UserRefNotifications" toml:"UserRefNotifications" yaml:"UserRefNotifications"`
	UserRefSchedulingCards              SchedulingCardSlice               `boil:"UserRefSchedulingCards" json:"UserRefSchedulingCards" toml:"UserRefSchedulingCards" yaml:"UserRefSchedulingCards"`
	UserAiContexts                      UserAiContextSlice                `boil:"UserAiContexts" json:"UserAiContexts" toml:"UserAiContexts" yaml:"UserAiContexts"`
	UserAiConvos                        UserAIConvoSlice                  `boil:"UserAiConvos" json:"UserAiConvos" toml:"UserAiConvos" yaml:"UserAiConvos"`
	UserAvailabilities                  UserAvailabilitySlice             `boil:"UserAvailabilities" json:"UserAvailabilities" toml:"UserAvailabilities" yaml:"UserAvailabilities"`
	UserBlockedContacts                 UserBlockedContactSlice           `boil:"UserBlockedContacts" json:"UserBlockedContacts" toml:"UserBlockedContacts" yaml:"UserBlockedContacts"`
	UserDateTypePreferences             UserDateTypePreferenceSlice       `boil:"UserDateTypePreferences" json:"UserDateTypePreferences" toml:"UserDateTypePreferences" yaml:"UserDateTypePreferences"`
	UserDatingPreferences               UserDatingPreferenceSlice         `boil:"UserDatingPreferences" json:"UserDatingPreferences" toml:"UserDatingPreferences" yaml:"UserDatingPreferences"`
	UserDietaryRestrictions             UserDietaryRestrictionSlice       `boil:"UserDietaryRestrictions" json:"UserDietaryRestrictions" toml:"UserDietaryRestrictions" yaml:"UserDietaryRestrictions"`
	UserElevenLabs                      UserElevenLabSlice                `boil:"UserElevenLabs" json:"UserElevenLabs" toml:"UserElevenLabs" yaml:"UserElevenLabs"`
	UserMobilityConstraints             UserMobilityConstraintSlice       `boil:"UserMobilityConstraints" json:"UserMobilityConstraints" toml:"UserMobilityConstraints" yaml:"UserMobilityConstraints"`
	UserPhotos                          UserPhotoSlice                    `boil:"UserPhotos" json:"UserPhotos" toml:"UserPhotos" yaml:"UserPhotos"`
	CreatedByUsers                      UserSlice                         `boil:"CreatedByUsers" json:"CreatedByUsers" toml:"CreatedByUsers" yaml:"CreatedByUsers"`
	LastUpdatedByUsers                  UserSlice                         `boil:"LastUpdatedByUsers" json:"LastUpdatedByUsers" toml:"LastUpdatedByUsers" yaml:"LastUpdatedByUsers"`
	SuggestedByRefVenueSuggestions      VenueSuggestionSlice              `boil:"SuggestedByRefVenueSuggestions" json:"SuggestedByRefVenueSuggestions" toml:"SuggestedByRefVenueSuggestions" yaml:"SuggestedByRefVenueSuggestions"`
	UserRefWingsEcnActionLogs           WingsEcnActionLogSlice            `boil:"UserRefWingsEcnActionLogs" json:"UserRefWingsEcnActionLogs" toml:"UserRefWingsEcnActionLogs" yaml:"UserRefWingsEcnActionLogs"`
	WingsEcnUserSubscriptionPlans       WingsEcnUserSubscriptionPlanSlice `boil:"WingsEcnUserSubscriptionPlans" json:"WingsEcnUserSubscriptionPlans" toml:"WingsEcnUserSubscriptionPlans" yaml:"WingsEcnUserSubscriptionPlans"`
}

// NewStruct creates a new relationship struct
func (*userR) NewStruct() *userR {
	return &userR{}
}

func (o *User) GetCreatedByUser() *User {
	if o == nil {
		return nil
	}

	return o.R.GetCreatedByUser()
}

func (r *userR) GetCreatedByUser() *User {
	if r == nil {
		return nil
	}

	return r.CreatedByUser
}

func (o *User) GetLastUpdatedByUser() *User {
	if o == nil {
		return nil
	}

	return o.R.GetLastUpdatedByUser()
}

func (r *userR) GetLastUpdatedByUser() *User {
	if r == nil {
		return nil
	}

	return r.LastUpdatedByUser
}

func (o *User) GetUserInviteCodeRef() *UserInviteCode {
	if o == nil {
		return nil
	}

	return o.R.GetUserInviteCodeRef()
}

func (r *userR) GetUserInviteCodeRef() *UserInviteCode {
	if r == nil {
		return nil
	}

	return r.UserInviteCodeRef
}

func (o *User) GetUserRefWingsEcnUserTotal() *WingsEcnUserTotal {
	if o == nil {
		return nil
	}

	return o.R.GetUserRefWingsEcnUserTotal()
}

func (r *userR) GetUserRefWingsEcnUserTotal() *WingsEcnUserTotal {
	if r == nil {
		return nil
	}

	return r.UserRefWingsEcnUserTotal
}

func (o *User) GetUserRefAgentLogs() AgentLogSlice {
	if o == nil {
		return nil
	}

	return o.R.GetUserRefAgentLogs()
}

func (r *userR) GetUserRefAgentLogs() AgentLogSlice {
	if r == nil {
		return nil
	}

	return r.UserRefAgentLogs
}

func (o *User) GetUserRefDateInstanceLogs() DateInstanceLogSlice {
	if o == nil {
		return nil
	}

	return o.R.GetUserRefDateInstanceLogs()
}

func (r *userR) GetUserRefDateInstanceLogs() DateInstanceLogSlice {
	if r == nil {
		return nil
	}

	return r.UserRefDateInstanceLogs
}

func (o *User) GetSuggestedByRefDateInstanceProposals() DateInstanceProposalSlice {
	if o == nil {
		return nil
	}

	return o.R.GetSuggestedByRefDateInstanceProposals()
}

func (r *userR) GetSuggestedByRefDateInstanceProposals() DateInstanceProposalSlice {
	if r == nil {
		return nil
	}

	return r.SuggestedByRefDateInstanceProposals
}

func (o *User) GetSenderMatchChatMessages() MatchChatMessageSlice {
	if o == nil {
		return nil
	}

	return o.R.GetSenderMatchChatMessages()
}

func (r *userR) GetSenderMatchChatMessages() MatchChatMessageSlice {
	if r == nil {
		return nil
	}

	return r.SenderMatchChatMessages
}

func (o *User) GetInitiatorUserRefMatchResults() MatchResultSlice {
	if o == nil {
		return nil
	}

	return o.R.GetInitiatorUserRefMatchResults()
}

func (r *userR) GetInitiatorUserRefMatchResults() MatchResultSlice {
	if r == nil {
		return nil
	}

	return r.InitiatorUserRefMatchResults
}

func (o *User) GetReceiverUserRefMatchResults() MatchResultSlice {
	if o == nil {
		return nil
	}

	return o.R.GetReceiverUserRefMatchResults()
}

func (r *userR) GetReceiverUserRefMatchResults() MatchResultSlice {
	if r == nil {
		return nil
	}

	return r.ReceiverUserRefMatchResults
}

func (o *User) GetUserARefMatchResults() MatchResultSlice {
	if o == nil {
		return nil
	}

	return o.R.GetUserARefMatchResults()
}

func (r *userR) GetUserARefMatchResults() MatchResultSlice {
	if r == nil {
		return nil
	}

	return r.UserARefMatchResults
}

func (o *User) GetUserBRefMatchResults() MatchResultSlice {
	if o == nil {
		return nil
	}

	return o.R.GetUserBRefMatchResults()
}

func (r *userR) GetUserBRefMatchResults() MatchResultSlice {
	if r == nil {
		return nil
	}

	return r.UserBRefMatchResults
}

func (o *User) GetUserRefNotifications() NotificationSlice {
	if o == nil {
		return nil
	}

	return o.R.GetUserRefNotifications()
}

func (r *userR) GetUserRefNotifications() NotificationSlice {
	if r == nil {
		return nil
	}

	return r.UserRefNotifications
}

func (o *User) GetUserRefSchedulingCards() SchedulingCardSlice {
	if o == nil {
		return nil
	}

	return o.R.GetUserRefSchedulingCards()
}

func (r *userR) GetUserRefSchedulingCards() SchedulingCardSlice {
	if r == nil {
		return nil
	}

	return r.UserRefSchedulingCards
}

func (o *User) GetUserAiContexts() UserAiContextSlice {
	if o == nil {
		return nil
	}

	return o.R.GetUserAiContexts()
}

func (r *userR) GetUserAiContexts() UserAiContextSlice {
	if r == nil {
		return nil
	}

	return r.UserAiContexts
}

func (o *User) GetUserAiConvos() UserAIConvoSlice {
	if o == nil {
		return nil
	}

	return o.R.GetUserAiConvos()
}

func (r *userR) GetUserAiConvos() UserAIConvoSlice {
	if r == nil {
		return nil
	}

	return r.UserAiConvos
}

func (o *User) GetUserAvailabilities() UserAvailabilitySlice {
	if o == nil {
		return nil
	}

	return o.R.GetUserAvailabilities()
}

func (r *userR) GetUserAvailabilities() UserAvailabilitySlice {
	if r == nil {
		return nil
	}

	return r.UserAvailabilities
}

func (o *User) GetUserBlockedContacts() UserBlockedContactSlice {
	if o == nil {
		return nil
	}

	return o.R.GetUserBlockedContacts()
}

func (r *userR) GetUserBlockedContacts() UserBlockedContactSlice {
	if r == nil {
		return nil
	}

	return r.UserBlockedContacts
}

func (o *User) GetUserDateTypePreferences() UserDateTypePreferenceSlice {
	if o == nil {
		return nil
	}

	return o.R.GetUserDateTypePreferences()
}

func (r *userR) GetUserDateTypePreferences() UserDateTypePreferenceSlice {
	if r == nil {
		return nil
	}

	return r.UserDateTypePreferences
}

func (o *User) GetUserDatingPreferences() UserDatingPreferenceSlice {
	if o == nil {
		return nil
	}

	return o.R.GetUserDatingPreferences()
}

func (r *userR) GetUserDatingPreferences() UserDatingPreferenceSlice {
	if r == nil {
		return nil
	}

	return r.UserDatingPreferences
}

func (o *User) GetUserDietaryRestrictions() UserDietaryRestrictionSlice {
	if o == nil {
		return nil
	}

	return o.R.GetUserDietaryRestrictions()
}

func (r *userR) GetUserDietaryRestrictions() UserDietaryRestrictionSlice {
	if r == nil {
		return nil
	}

	return r.UserDietaryRestrictions
}

func (o *User) GetUserElevenLabs() UserElevenLabSlice {
	if o == nil {
		return nil
	}

	return o.R.GetUserElevenLabs()
}

func (r *userR) GetUserElevenLabs() UserElevenLabSlice {
	if r == nil {
		return nil
	}

	return r.UserElevenLabs
}

func (o *User) GetUserMobilityConstraints() UserMobilityConstraintSlice {
	if o == nil {
		return nil
	}

	return o.R.GetUserMobilityConstraints()
}

func (r *userR) GetUserMobilityConstraints() UserMobilityConstraintSlice {
	if r == nil {
		return nil
	}

	return r.UserMobilityConstraints
}

func (o *User) GetUserPhotos() UserPhotoSlice {
	if o == nil {
		return nil
	}

	return o.R.GetUserPhotos()
}

func (r *userR) GetUserPhotos() UserPhotoSlice {
	if r == nil {
		return nil
	}

	return r.UserPhotos
}

func (o *User) GetCreatedByUsers() UserSlice {
	if o == nil {
		return nil
	}

	return o.R.GetCreatedByUsers()
}

func (r *userR) GetCreatedByUsers() UserSlice {
	if r == nil {
		return nil
	}

	return r.CreatedByUsers
}

func (o *User) GetLastUpdatedByUsers() UserSlice {
	if o == nil {
		return nil
	}

	return o.R.GetLastUpdatedByUsers()
}

func (r *userR) GetLastUpdatedByUsers() UserSlice {
	if r == nil {
		return nil
	}

	return r.LastUpdatedByUsers
}

func (o *User) GetSuggestedByRefVenueSuggestions() VenueSuggestionSlice {
	if o == nil {
		return nil
	}

	return o.R.GetSuggestedByRefVenueSuggestions()
}

func (r *userR) GetSuggestedByRefVenueSuggestions() VenueSuggestionSlice {
	if r == nil {
		return nil
	}

	return r.SuggestedByRefVenueSuggestions
}

func (o *User) GetUserRefWingsEcnActionLogs() WingsEcnActionLogSlice {
	if o == nil {
		return nil
	}

	return o.R.GetUserRefWingsEcnActionLogs()
}

func (r *userR) GetUserRefWingsEcnActionLogs() WingsEcnActionLogSlice {
	if r == nil {
		return nil
	}

	return r.UserRefWingsEcnActionLogs
}

func (o *User) GetWingsEcnUserSubscriptionPlans() WingsEcnUserSubscriptionPlanSlice {
	if o == nil {
		return nil
	}

	return o.R.GetWingsEcnUserSubscriptionPlans()
}

func (r *userR) GetWingsEcnUserSubscriptionPlans() WingsEcnUserSubscriptionPlanSlice {
	if r == nil {
		return nil
	}

	return r.WingsEcnUserSubscriptionPlans
}

// userL is where Load methods for each relationship are stored.
type userL struct{}

var (
	userAllColumns            = []string{"id", "supabase_id", "first_name", "last_name", "email", "password", "address", "mobile_number", "birthday", "gender", "height_cm", "dating_pref_age_range_start", "dating_pref_age_range_end", "agent_dating", "reset_token", "registration_code", "registration_code_sent_at", "last_checked_call_status", "agent_deployed", "selected_intro_id", "registered_successfully", "mobile_code", "sha256_hash", "mobile_confirmed", "user_invite_code_ref_id", "created_by", "latest_transcript_id", "latest_transcript_ts", "has_transcript", "latitude", "longitude", "ideal_first_date_phrase", "date_type_bucket", "date_type_subtype", "user_type", "sexuality", "sexuality_is_visible", "last_updated_by", "created_at", "updated_at", "is_active", "is_test_user"}
	userColumnsWithoutDefault = []string{"email"}
	userColumnsWithDefault    = []string{"id", "supabase_id", "first_name", "last_name", "password", "address", "mobile_number", "birthday", "gender", "height_cm", "dating_pref_age_range_start", "dating_pref_age_range_end", "agent_dating", "reset_token", "registration_code", "registration_code_sent_at", "last_checked_call_status", "agent_deployed", "selected_intro_id", "registered_successfully", "mobile_code", "sha256_hash", "mobile_confirmed", "user_invite_code_ref_id", "created_by", "latest_transcript_id", "latest_transcript_ts", "has_transcript", "latitude", "longitude", "ideal_first_date_phrase", "date_type_bucket", "date_type_subtype", "user_type", "sexuality", "sexuality_is_visible", "last_updated_by", "created_at", "updated_at", "is_active", "is_test_user"}
	userPrimaryKeyColumns     = []string{"id"}
	userGeneratedColumns      = []string{}
)

type (
	// UserSlice is an alias for a slice of pointers to User.
	// This should almost always be used instead of []User.
	UserSlice []*User
	// UserHook is the signature for custom User hook methods
	UserHook func(context.Context, boil.ContextExecutor, *User) error

	userQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	userType                 = reflect.TypeOf(&User{})
	userMapping              = queries.MakeStructMapping(userType)
	userPrimaryKeyMapping, _ = queries.BindMapping(userType, userMapping, userPrimaryKeyColumns)
	userInsertCacheMut       sync.RWMutex
	userInsertCache          = make(map[string]insertCache)
	userUpdateCacheMut       sync.RWMutex
	userUpdateCache          = make(map[string]updateCache)
	userUpsertCacheMut       sync.RWMutex
	userUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var userAfterSelectMu sync.Mutex
var userAfterSelectHooks []UserHook

var userBeforeInsertMu sync.Mutex
var userBeforeInsertHooks []UserHook
var userAfterInsertMu sync.Mutex
var userAfterInsertHooks []UserHook

var userBeforeUpdateMu sync.Mutex
var userBeforeUpdateHooks []UserHook
var userAfterUpdateMu sync.Mutex
var userAfterUpdateHooks []UserHook

var userBeforeDeleteMu sync.Mutex
var userBeforeDeleteHooks []UserHook
var userAfterDeleteMu sync.Mutex
var userAfterDeleteHooks []UserHook

var userBeforeUpsertMu sync.Mutex
var userBeforeUpsertHooks []UserHook
var userAfterUpsertMu sync.Mutex
var userAfterUpsertHooks []UserHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *User) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *User) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *User) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *User) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *User) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *User) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *User) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *User) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *User) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range userAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddUserHook registers your hook function for all future operations.
func AddUserHook(hookPoint boil.HookPoint, userHook UserHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		userAfterSelectMu.Lock()
		userAfterSelectHooks = append(userAfterSelectHooks, userHook)
		userAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		userBeforeInsertMu.Lock()
		userBeforeInsertHooks = append(userBeforeInsertHooks, userHook)
		userBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		userAfterInsertMu.Lock()
		userAfterInsertHooks = append(userAfterInsertHooks, userHook)
		userAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		userBeforeUpdateMu.Lock()
		userBeforeUpdateHooks = append(userBeforeUpdateHooks, userHook)
		userBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		userAfterUpdateMu.Lock()
		userAfterUpdateHooks = append(userAfterUpdateHooks, userHook)
		userAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		userBeforeDeleteMu.Lock()
		userBeforeDeleteHooks = append(userBeforeDeleteHooks, userHook)
		userBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		userAfterDeleteMu.Lock()
		userAfterDeleteHooks = append(userAfterDeleteHooks, userHook)
		userAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		userBeforeUpsertMu.Lock()
		userBeforeUpsertHooks = append(userBeforeUpsertHooks, userHook)
		userBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		userAfterUpsertMu.Lock()
		userAfterUpsertHooks = append(userAfterUpsertHooks, userHook)
		userAfterUpsertMu.Unlock()
	}
}

// One returns a single user record from the query.
func (q userQuery) One(ctx context.Context, exec boil.ContextExecutor) (*User, error) {
	o := &User{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "pgmodel: failed to execute a one query for users")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all User records from the query.
func (q userQuery) All(ctx context.Context, exec boil.ContextExecutor) (UserSlice, error) {
	var o []*User

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "pgmodel: failed to assign all query results to User slice")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all User records in the query.
func (q userQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: failed to count users rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q userQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "pgmodel: failed to check if users exists")
	}

	return count > 0, nil
}

// CreatedByUser pointed to by the foreign key.
func (o *User) CreatedByUser(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.CreatedBy),
	}

	queryMods = append(queryMods, mods...)

	return Users(queryMods...)
}

// LastUpdatedByUser pointed to by the foreign key.
func (o *User) LastUpdatedByUser(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.LastUpdatedBy),
	}

	queryMods = append(queryMods, mods...)

	return Users(queryMods...)
}

// UserInviteCodeRef pointed to by the foreign key.
func (o *User) UserInviteCodeRef(mods ...qm.QueryMod) userInviteCodeQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.UserInviteCodeRefID),
	}

	queryMods = append(queryMods, mods...)

	return UserInviteCodes(queryMods...)
}

// UserRefWingsEcnUserTotal pointed to by the foreign key.
func (o *User) UserRefWingsEcnUserTotal(mods ...qm.QueryMod) wingsEcnUserTotalQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"user_ref_id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	return WingsEcnUserTotals(queryMods...)
}

// UserRefAgentLogs retrieves all the agent_log's AgentLogs with an executor via user_ref_id column.
func (o *User) UserRefAgentLogs(mods ...qm.QueryMod) agentLogQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"agent_log\".\"user_ref_id\"=?", o.ID),
	)

	return AgentLogs(queryMods...)
}

// UserRefDateInstanceLogs retrieves all the date_instance_log's DateInstanceLogs with an executor via user_ref_id column.
func (o *User) UserRefDateInstanceLogs(mods ...qm.QueryMod) dateInstanceLogQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"date_instance_log\".\"user_ref_id\"=?", o.ID),
	)

	return DateInstanceLogs(queryMods...)
}

// SuggestedByRefDateInstanceProposals retrieves all the date_instance_proposal's DateInstanceProposals with an executor via suggested_by_ref_id column.
func (o *User) SuggestedByRefDateInstanceProposals(mods ...qm.QueryMod) dateInstanceProposalQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"date_instance_proposal\".\"suggested_by_ref_id\"=?", o.ID),
	)

	return DateInstanceProposals(queryMods...)
}

// SenderMatchChatMessages retrieves all the match_chat_message's MatchChatMessages with an executor via sender_id column.
func (o *User) SenderMatchChatMessages(mods ...qm.QueryMod) matchChatMessageQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"match_chat_message\".\"sender_id\"=?", o.ID),
	)

	return MatchChatMessages(queryMods...)
}

// InitiatorUserRefMatchResults retrieves all the match_result's MatchResults with an executor via initiator_user_ref_id column.
func (o *User) InitiatorUserRefMatchResults(mods ...qm.QueryMod) matchResultQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"match_result\".\"initiator_user_ref_id\"=?", o.ID),
	)

	return MatchResults(queryMods...)
}

// ReceiverUserRefMatchResults retrieves all the match_result's MatchResults with an executor via receiver_user_ref_id column.
func (o *User) ReceiverUserRefMatchResults(mods ...qm.QueryMod) matchResultQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"match_result\".\"receiver_user_ref_id\"=?", o.ID),
	)

	return MatchResults(queryMods...)
}

// UserARefMatchResults retrieves all the match_result's MatchResults with an executor via initiator_user_ref_id column.
func (o *User) UserARefMatchResults(mods ...qm.QueryMod) matchResultQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"match_result\".\"initiator_user_ref_id\"=?", o.ID),
	)

	return MatchResults(queryMods...)
}

// UserBRefMatchResults retrieves all the match_result's MatchResults with an executor via receiver_user_ref_id column.
func (o *User) UserBRefMatchResults(mods ...qm.QueryMod) matchResultQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"match_result\".\"receiver_user_ref_id\"=?", o.ID),
	)

	return MatchResults(queryMods...)
}

// UserRefNotifications retrieves all the notification's Notifications with an executor via user_ref_id column.
func (o *User) UserRefNotifications(mods ...qm.QueryMod) notificationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"notification\".\"user_ref_id\"=?", o.ID),
	)

	return Notifications(queryMods...)
}

// UserRefSchedulingCards retrieves all the scheduling_card's SchedulingCards with an executor via user_ref_id column.
func (o *User) UserRefSchedulingCards(mods ...qm.QueryMod) schedulingCardQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"scheduling_card\".\"user_ref_id\"=?", o.ID),
	)

	return SchedulingCards(queryMods...)
}

// UserAiContexts retrieves all the user_ai_context's UserAiContexts with an executor.
func (o *User) UserAiContexts(mods ...qm.QueryMod) userAiContextQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_ai_context\".\"user_id\"=?", o.ID),
	)

	return UserAiContexts(queryMods...)
}

// UserAiConvos retrieves all the user_ai_convo's UserAIConvos with an executor via user_id column.
func (o *User) UserAiConvos(mods ...qm.QueryMod) UserAIConvoQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_ai_convo\".\"user_id\"=?", o.ID),
	)

	return UserAIConvos(queryMods...)
}

// UserAvailabilities retrieves all the user_availability's UserAvailabilities with an executor.
func (o *User) UserAvailabilities(mods ...qm.QueryMod) userAvailabilityQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_availability\".\"user_id\"=?", o.ID),
	)

	return UserAvailabilities(queryMods...)
}

// UserBlockedContacts retrieves all the user_blocked_contact's UserBlockedContacts with an executor.
func (o *User) UserBlockedContacts(mods ...qm.QueryMod) userBlockedContactQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_blocked_contact\".\"user_id\"=?", o.ID),
	)

	return UserBlockedContacts(queryMods...)
}

// UserDateTypePreferences retrieves all the user_date_type_preference's UserDateTypePreferences with an executor.
func (o *User) UserDateTypePreferences(mods ...qm.QueryMod) userDateTypePreferenceQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_date_type_preference\".\"user_id\"=?", o.ID),
	)

	return UserDateTypePreferences(queryMods...)
}

// UserDatingPreferences retrieves all the user_dating_preference's UserDatingPreferences with an executor.
func (o *User) UserDatingPreferences(mods ...qm.QueryMod) userDatingPreferenceQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_dating_preferences\".\"user_id\"=?", o.ID),
	)

	return UserDatingPreferences(queryMods...)
}

// UserDietaryRestrictions retrieves all the user_dietary_restriction's UserDietaryRestrictions with an executor.
func (o *User) UserDietaryRestrictions(mods ...qm.QueryMod) userDietaryRestrictionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_dietary_restriction\".\"user_id\"=?", o.ID),
	)

	return UserDietaryRestrictions(queryMods...)
}

// UserElevenLabs retrieves all the user_eleven_lab's UserElevenLabs with an executor.
func (o *User) UserElevenLabs(mods ...qm.QueryMod) userElevenLabQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_eleven_labs\".\"user_id\"=?", o.ID),
	)

	return UserElevenLabs(queryMods...)
}

// UserMobilityConstraints retrieves all the user_mobility_constraint's UserMobilityConstraints with an executor.
func (o *User) UserMobilityConstraints(mods ...qm.QueryMod) userMobilityConstraintQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_mobility_constraint\".\"user_id\"=?", o.ID),
	)

	return UserMobilityConstraints(queryMods...)
}

// UserPhotos retrieves all the user_photo's UserPhotos with an executor.
func (o *User) UserPhotos(mods ...qm.QueryMod) userPhotoQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_photo\".\"user_id\"=?", o.ID),
	)

	return UserPhotos(queryMods...)
}

// CreatedByUsers retrieves all the user's Users with an executor via created_by column.
func (o *User) CreatedByUsers(mods ...qm.QueryMod) userQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"users\".\"created_by\"=?", o.ID),
	)

	return Users(queryMods...)
}

// LastUpdatedByUsers retrieves all the user's Users with an executor via last_updated_by column.
func (o *User) LastUpdatedByUsers(mods ...qm.QueryMod) userQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"users\".\"last_updated_by\"=?", o.ID),
	)

	return Users(queryMods...)
}

// SuggestedByRefVenueSuggestions retrieves all the venue_suggestion's VenueSuggestions with an executor via suggested_by_ref_id column.
func (o *User) SuggestedByRefVenueSuggestions(mods ...qm.QueryMod) venueSuggestionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"venue_suggestion\".\"suggested_by_ref_id\"=?", o.ID),
	)

	return VenueSuggestions(queryMods...)
}

// UserRefWingsEcnActionLogs retrieves all the wings_ecn_action_log's WingsEcnActionLogs with an executor via user_ref_id column.
func (o *User) UserRefWingsEcnActionLogs(mods ...qm.QueryMod) wingsEcnActionLogQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"wings_ecn_action_log\".\"user_ref_id\"=?", o.ID),
	)

	return WingsEcnActionLogs(queryMods...)
}

// WingsEcnUserSubscriptionPlans retrieves all the wings_ecn_user_subscription_plan's WingsEcnUserSubscriptionPlans with an executor.
func (o *User) WingsEcnUserSubscriptionPlans(mods ...qm.QueryMod) wingsEcnUserSubscriptionPlanQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"wings_ecn_user_subscription_plan\".\"user_id\"=?", o.ID),
	)

	return WingsEcnUserSubscriptionPlans(queryMods...)
}

// LoadCreatedByUser allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (userL) LoadCreatedByUser(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		if !queries.IsNil(object.CreatedBy) {
			args[object.CreatedBy] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			if !queries.IsNil(obj.CreatedBy) {
				args[obj.CreatedBy] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.CreatedByUser = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.CreatedByUsers = append(foreign.R.CreatedByUsers, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CreatedBy, foreign.ID) {
				local.R.CreatedByUser = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.CreatedByUsers = append(foreign.R.CreatedByUsers, local)
				break
			}
		}
	}

	return nil
}

// LoadLastUpdatedByUser allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (userL) LoadLastUpdatedByUser(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		if !queries.IsNil(object.LastUpdatedBy) {
			args[object.LastUpdatedBy] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			if !queries.IsNil(obj.LastUpdatedBy) {
				args[obj.LastUpdatedBy] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.LastUpdatedByUser = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.LastUpdatedByUsers = append(foreign.R.LastUpdatedByUsers, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.LastUpdatedBy, foreign.ID) {
				local.R.LastUpdatedByUser = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.LastUpdatedByUsers = append(foreign.R.LastUpdatedByUsers, local)
				break
			}
		}
	}

	return nil
}

// LoadUserInviteCodeRef allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (userL) LoadUserInviteCodeRef(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		if !queries.IsNil(object.UserInviteCodeRefID) {
			args[object.UserInviteCodeRefID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			if !queries.IsNil(obj.UserInviteCodeRefID) {
				args[obj.UserInviteCodeRefID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`user_invite_code`),
		qm.WhereIn(`user_invite_code.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load UserInviteCode")
	}

	var resultSlice []*UserInviteCode
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice UserInviteCode")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for user_invite_code")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_invite_code")
	}

	if len(userInviteCodeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.UserInviteCodeRef = foreign
		if foreign.R == nil {
			foreign.R = &userInviteCodeR{}
		}
		foreign.R.UserInviteCodeRefUsers = append(foreign.R.UserInviteCodeRefUsers, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.UserInviteCodeRefID, foreign.ID) {
				local.R.UserInviteCodeRef = foreign
				if foreign.R == nil {
					foreign.R = &userInviteCodeR{}
				}
				foreign.R.UserInviteCodeRefUsers = append(foreign.R.UserInviteCodeRefUsers, local)
				break
			}
		}
	}

	return nil
}

// LoadUserRefWingsEcnUserTotal allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (userL) LoadUserRefWingsEcnUserTotal(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}

			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`wings_ecn_user_totals`),
		qm.WhereIn(`wings_ecn_user_totals.user_ref_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load WingsEcnUserTotal")
	}

	var resultSlice []*WingsEcnUserTotal
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice WingsEcnUserTotal")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for wings_ecn_user_totals")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for wings_ecn_user_totals")
	}

	if len(wingsEcnUserTotalAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.UserRefWingsEcnUserTotal = foreign
		if foreign.R == nil {
			foreign.R = &wingsEcnUserTotalR{}
		}
		foreign.R.UserRef = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ID == foreign.UserRefID {
				local.R.UserRefWingsEcnUserTotal = foreign
				if foreign.R == nil {
					foreign.R = &wingsEcnUserTotalR{}
				}
				foreign.R.UserRef = local
				break
			}
		}
	}

	return nil
}

// LoadUserRefAgentLogs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserRefAgentLogs(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`agent_log`),
		qm.WhereIn(`agent_log.user_ref_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load agent_log")
	}

	var resultSlice []*AgentLog
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice agent_log")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on agent_log")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for agent_log")
	}

	if len(agentLogAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserRefAgentLogs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &agentLogR{}
			}
			foreign.R.UserRef = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserRefID {
				local.R.UserRefAgentLogs = append(local.R.UserRefAgentLogs, foreign)
				if foreign.R == nil {
					foreign.R = &agentLogR{}
				}
				foreign.R.UserRef = local
				break
			}
		}
	}

	return nil
}

// LoadUserRefDateInstanceLogs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserRefDateInstanceLogs(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`date_instance_log`),
		qm.WhereIn(`date_instance_log.user_ref_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load date_instance_log")
	}

	var resultSlice []*DateInstanceLog
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice date_instance_log")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on date_instance_log")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for date_instance_log")
	}

	if len(dateInstanceLogAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserRefDateInstanceLogs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dateInstanceLogR{}
			}
			foreign.R.UserRef = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.UserRefID) {
				local.R.UserRefDateInstanceLogs = append(local.R.UserRefDateInstanceLogs, foreign)
				if foreign.R == nil {
					foreign.R = &dateInstanceLogR{}
				}
				foreign.R.UserRef = local
				break
			}
		}
	}

	return nil
}

// LoadSuggestedByRefDateInstanceProposals allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadSuggestedByRefDateInstanceProposals(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`date_instance_proposal`),
		qm.WhereIn(`date_instance_proposal.suggested_by_ref_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load date_instance_proposal")
	}

	var resultSlice []*DateInstanceProposal
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice date_instance_proposal")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on date_instance_proposal")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for date_instance_proposal")
	}

	if len(dateInstanceProposalAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.SuggestedByRefDateInstanceProposals = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dateInstanceProposalR{}
			}
			foreign.R.SuggestedByRef = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.SuggestedByRefID {
				local.R.SuggestedByRefDateInstanceProposals = append(local.R.SuggestedByRefDateInstanceProposals, foreign)
				if foreign.R == nil {
					foreign.R = &dateInstanceProposalR{}
				}
				foreign.R.SuggestedByRef = local
				break
			}
		}
	}

	return nil
}

// LoadSenderMatchChatMessages allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadSenderMatchChatMessages(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`match_chat_message`),
		qm.WhereIn(`match_chat_message.sender_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load match_chat_message")
	}

	var resultSlice []*MatchChatMessage
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice match_chat_message")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on match_chat_message")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for match_chat_message")
	}

	if len(matchChatMessageAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.SenderMatchChatMessages = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &matchChatMessageR{}
			}
			foreign.R.Sender = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.SenderID {
				local.R.SenderMatchChatMessages = append(local.R.SenderMatchChatMessages, foreign)
				if foreign.R == nil {
					foreign.R = &matchChatMessageR{}
				}
				foreign.R.Sender = local
				break
			}
		}
	}

	return nil
}

// LoadInitiatorUserRefMatchResults allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadInitiatorUserRefMatchResults(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`match_result`),
		qm.WhereIn(`match_result.initiator_user_ref_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load match_result")
	}

	var resultSlice []*MatchResult
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice match_result")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on match_result")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for match_result")
	}

	if len(matchResultAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.InitiatorUserRefMatchResults = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &matchResultR{}
			}
			foreign.R.InitiatorUserRef = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.InitiatorUserRefID {
				local.R.InitiatorUserRefMatchResults = append(local.R.InitiatorUserRefMatchResults, foreign)
				if foreign.R == nil {
					foreign.R = &matchResultR{}
				}
				foreign.R.InitiatorUserRef = local
				break
			}
		}
	}

	return nil
}

// LoadReceiverUserRefMatchResults allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadReceiverUserRefMatchResults(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`match_result`),
		qm.WhereIn(`match_result.receiver_user_ref_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load match_result")
	}

	var resultSlice []*MatchResult
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice match_result")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on match_result")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for match_result")
	}

	if len(matchResultAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ReceiverUserRefMatchResults = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &matchResultR{}
			}
			foreign.R.ReceiverUserRef = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ReceiverUserRefID {
				local.R.ReceiverUserRefMatchResults = append(local.R.ReceiverUserRefMatchResults, foreign)
				if foreign.R == nil {
					foreign.R = &matchResultR{}
				}
				foreign.R.ReceiverUserRef = local
				break
			}
		}
	}

	return nil
}

// LoadUserARefMatchResults allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserARefMatchResults(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`match_result`),
		qm.WhereIn(`match_result.initiator_user_ref_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load match_result")
	}

	var resultSlice []*MatchResult
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice match_result")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on match_result")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for match_result")
	}

	if len(matchResultAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserARefMatchResults = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &matchResultR{}
			}
			foreign.R.UserARef = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.InitiatorUserRefID {
				local.R.UserARefMatchResults = append(local.R.UserARefMatchResults, foreign)
				if foreign.R == nil {
					foreign.R = &matchResultR{}
				}
				foreign.R.UserARef = local
				break
			}
		}
	}

	return nil
}

// LoadUserBRefMatchResults allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserBRefMatchResults(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`match_result`),
		qm.WhereIn(`match_result.receiver_user_ref_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load match_result")
	}

	var resultSlice []*MatchResult
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice match_result")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on match_result")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for match_result")
	}

	if len(matchResultAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserBRefMatchResults = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &matchResultR{}
			}
			foreign.R.UserBRef = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.ReceiverUserRefID {
				local.R.UserBRefMatchResults = append(local.R.UserBRefMatchResults, foreign)
				if foreign.R == nil {
					foreign.R = &matchResultR{}
				}
				foreign.R.UserBRef = local
				break
			}
		}
	}

	return nil
}

// LoadUserRefNotifications allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserRefNotifications(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`notification`),
		qm.WhereIn(`notification.user_ref_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load notification")
	}

	var resultSlice []*Notification
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice notification")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on notification")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for notification")
	}

	if len(notificationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserRefNotifications = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &notificationR{}
			}
			foreign.R.UserRef = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserRefID {
				local.R.UserRefNotifications = append(local.R.UserRefNotifications, foreign)
				if foreign.R == nil {
					foreign.R = &notificationR{}
				}
				foreign.R.UserRef = local
				break
			}
		}
	}

	return nil
}

// LoadUserRefSchedulingCards allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserRefSchedulingCards(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`scheduling_card`),
		qm.WhereIn(`scheduling_card.user_ref_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load scheduling_card")
	}

	var resultSlice []*SchedulingCard
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice scheduling_card")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on scheduling_card")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for scheduling_card")
	}

	if len(schedulingCardAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserRefSchedulingCards = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &schedulingCardR{}
			}
			foreign.R.UserRef = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserRefID {
				local.R.UserRefSchedulingCards = append(local.R.UserRefSchedulingCards, foreign)
				if foreign.R == nil {
					foreign.R = &schedulingCardR{}
				}
				foreign.R.UserRef = local
				break
			}
		}
	}

	return nil
}

// LoadUserAiContexts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserAiContexts(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`user_ai_context`),
		qm.WhereIn(`user_ai_context.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_ai_context")
	}

	var resultSlice []*UserAiContext
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_ai_context")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_ai_context")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_ai_context")
	}

	if len(userAiContextAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserAiContexts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userAiContextR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.UserAiContexts = append(local.R.UserAiContexts, foreign)
				if foreign.R == nil {
					foreign.R = &userAiContextR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadUserAiConvos allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserAiConvos(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`user_ai_convo`),
		qm.WhereIn(`user_ai_convo.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_ai_convo")
	}

	var resultSlice []*UserAIConvo
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_ai_convo")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_ai_convo")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_ai_convo")
	}

	if len(UserAIConvoAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserAiConvos = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &UserAIConvoR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.UserAiConvos = append(local.R.UserAiConvos, foreign)
				if foreign.R == nil {
					foreign.R = &UserAIConvoR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadUserAvailabilities allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserAvailabilities(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`user_availability`),
		qm.WhereIn(`user_availability.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_availability")
	}

	var resultSlice []*UserAvailability
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_availability")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_availability")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_availability")
	}

	if len(userAvailabilityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserAvailabilities = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userAvailabilityR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.UserAvailabilities = append(local.R.UserAvailabilities, foreign)
				if foreign.R == nil {
					foreign.R = &userAvailabilityR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadUserBlockedContacts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserBlockedContacts(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`user_blocked_contact`),
		qm.WhereIn(`user_blocked_contact.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_blocked_contact")
	}

	var resultSlice []*UserBlockedContact
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_blocked_contact")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_blocked_contact")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_blocked_contact")
	}

	if len(userBlockedContactAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserBlockedContacts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userBlockedContactR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.UserBlockedContacts = append(local.R.UserBlockedContacts, foreign)
				if foreign.R == nil {
					foreign.R = &userBlockedContactR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadUserDateTypePreferences allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserDateTypePreferences(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`user_date_type_preference`),
		qm.WhereIn(`user_date_type_preference.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_date_type_preference")
	}

	var resultSlice []*UserDateTypePreference
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_date_type_preference")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_date_type_preference")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_date_type_preference")
	}

	if len(userDateTypePreferenceAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserDateTypePreferences = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userDateTypePreferenceR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.UserDateTypePreferences = append(local.R.UserDateTypePreferences, foreign)
				if foreign.R == nil {
					foreign.R = &userDateTypePreferenceR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadUserDatingPreferences allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserDatingPreferences(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`user_dating_preferences`),
		qm.WhereIn(`user_dating_preferences.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_dating_preferences")
	}

	var resultSlice []*UserDatingPreference
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_dating_preferences")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_dating_preferences")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_dating_preferences")
	}

	if len(userDatingPreferenceAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserDatingPreferences = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userDatingPreferenceR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.UserDatingPreferences = append(local.R.UserDatingPreferences, foreign)
				if foreign.R == nil {
					foreign.R = &userDatingPreferenceR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadUserDietaryRestrictions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserDietaryRestrictions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`user_dietary_restriction`),
		qm.WhereIn(`user_dietary_restriction.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_dietary_restriction")
	}

	var resultSlice []*UserDietaryRestriction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_dietary_restriction")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_dietary_restriction")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_dietary_restriction")
	}

	if len(userDietaryRestrictionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserDietaryRestrictions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userDietaryRestrictionR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.UserDietaryRestrictions = append(local.R.UserDietaryRestrictions, foreign)
				if foreign.R == nil {
					foreign.R = &userDietaryRestrictionR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadUserElevenLabs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserElevenLabs(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`user_eleven_labs`),
		qm.WhereIn(`user_eleven_labs.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_eleven_labs")
	}

	var resultSlice []*UserElevenLab
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_eleven_labs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_eleven_labs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_eleven_labs")
	}

	if len(userElevenLabAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserElevenLabs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userElevenLabR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.UserElevenLabs = append(local.R.UserElevenLabs, foreign)
				if foreign.R == nil {
					foreign.R = &userElevenLabR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadUserMobilityConstraints allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserMobilityConstraints(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`user_mobility_constraint`),
		qm.WhereIn(`user_mobility_constraint.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_mobility_constraint")
	}

	var resultSlice []*UserMobilityConstraint
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_mobility_constraint")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_mobility_constraint")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_mobility_constraint")
	}

	if len(userMobilityConstraintAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserMobilityConstraints = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userMobilityConstraintR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.UserMobilityConstraints = append(local.R.UserMobilityConstraints, foreign)
				if foreign.R == nil {
					foreign.R = &userMobilityConstraintR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadUserPhotos allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserPhotos(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`user_photo`),
		qm.WhereIn(`user_photo.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_photo")
	}

	var resultSlice []*UserPhoto
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_photo")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_photo")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_photo")
	}

	if len(userPhotoAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserPhotos = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userPhotoR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.UserPhotos = append(local.R.UserPhotos, foreign)
				if foreign.R == nil {
					foreign.R = &userPhotoR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// LoadCreatedByUsers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadCreatedByUsers(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.created_by in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load users")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice users")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CreatedByUsers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userR{}
			}
			foreign.R.CreatedByUser = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.CreatedBy) {
				local.R.CreatedByUsers = append(local.R.CreatedByUsers, foreign)
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.CreatedByUser = local
				break
			}
		}
	}

	return nil
}

// LoadLastUpdatedByUsers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadLastUpdatedByUsers(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.last_updated_by in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load users")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice users")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.LastUpdatedByUsers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userR{}
			}
			foreign.R.LastUpdatedByUser = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.LastUpdatedBy) {
				local.R.LastUpdatedByUsers = append(local.R.LastUpdatedByUsers, foreign)
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.LastUpdatedByUser = local
				break
			}
		}
	}

	return nil
}

// LoadSuggestedByRefVenueSuggestions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadSuggestedByRefVenueSuggestions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`venue_suggestion`),
		qm.WhereIn(`venue_suggestion.suggested_by_ref_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load venue_suggestion")
	}

	var resultSlice []*VenueSuggestion
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice venue_suggestion")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on venue_suggestion")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for venue_suggestion")
	}

	if len(venueSuggestionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.SuggestedByRefVenueSuggestions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &venueSuggestionR{}
			}
			foreign.R.SuggestedByRef = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.SuggestedByRefID {
				local.R.SuggestedByRefVenueSuggestions = append(local.R.SuggestedByRefVenueSuggestions, foreign)
				if foreign.R == nil {
					foreign.R = &venueSuggestionR{}
				}
				foreign.R.SuggestedByRef = local
				break
			}
		}
	}

	return nil
}

// LoadUserRefWingsEcnActionLogs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadUserRefWingsEcnActionLogs(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`wings_ecn_action_log`),
		qm.WhereIn(`wings_ecn_action_log.user_ref_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load wings_ecn_action_log")
	}

	var resultSlice []*WingsEcnActionLog
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice wings_ecn_action_log")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on wings_ecn_action_log")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for wings_ecn_action_log")
	}

	if len(wingsEcnActionLogAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserRefWingsEcnActionLogs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &wingsEcnActionLogR{}
			}
			foreign.R.UserRef = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserRefID {
				local.R.UserRefWingsEcnActionLogs = append(local.R.UserRefWingsEcnActionLogs, foreign)
				if foreign.R == nil {
					foreign.R = &wingsEcnActionLogR{}
				}
				foreign.R.UserRef = local
				break
			}
		}
	}

	return nil
}

// LoadWingsEcnUserSubscriptionPlans allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userL) LoadWingsEcnUserSubscriptionPlans(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUser interface{}, mods queries.Applicator) error {
	var slice []*User
	var object *User

	if singular {
		var ok bool
		object, ok = maybeUser.(*User)
		if !ok {
			object = new(User)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeUser))
			}
		}
	} else {
		s, ok := maybeUser.(*[]*User)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeUser)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeUser))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &userR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`wings_ecn_user_subscription_plan`),
		qm.WhereIn(`wings_ecn_user_subscription_plan.user_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load wings_ecn_user_subscription_plan")
	}

	var resultSlice []*WingsEcnUserSubscriptionPlan
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice wings_ecn_user_subscription_plan")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on wings_ecn_user_subscription_plan")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for wings_ecn_user_subscription_plan")
	}

	if len(wingsEcnUserSubscriptionPlanAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.WingsEcnUserSubscriptionPlans = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &wingsEcnUserSubscriptionPlanR{}
			}
			foreign.R.User = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.UserID {
				local.R.WingsEcnUserSubscriptionPlans = append(local.R.WingsEcnUserSubscriptionPlans, foreign)
				if foreign.R == nil {
					foreign.R = &wingsEcnUserSubscriptionPlanR{}
				}
				foreign.R.User = local
				break
			}
		}
	}

	return nil
}

// SetCreatedByUser of the user to the related item.
// Sets o.R.CreatedByUser to related.
// Adds o to related.R.CreatedByUsers.
func (o *User) SetCreatedByUser(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"users\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"created_by"}),
		strmangle.WhereClause("\"", "\"", 2, userPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CreatedBy, related.ID)
	if o.R == nil {
		o.R = &userR{
			CreatedByUser: related,
		}
	} else {
		o.R.CreatedByUser = related
	}

	if related.R == nil {
		related.R = &userR{
			CreatedByUsers: UserSlice{o},
		}
	} else {
		related.R.CreatedByUsers = append(related.R.CreatedByUsers, o)
	}

	return nil
}

// RemoveCreatedByUser relationship.
// Sets o.R.CreatedByUser to nil.
// Removes o from all passed in related items' relationships struct.
func (o *User) RemoveCreatedByUser(ctx context.Context, exec boil.ContextExecutor, related *User) error {
	var err error

	queries.SetScanner(&o.CreatedBy, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("created_by")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.CreatedByUser = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.CreatedByUsers {
		if queries.Equal(o.CreatedBy, ri.CreatedBy) {
			continue
		}

		ln := len(related.R.CreatedByUsers)
		if ln > 1 && i < ln-1 {
			related.R.CreatedByUsers[i] = related.R.CreatedByUsers[ln-1]
		}
		related.R.CreatedByUsers = related.R.CreatedByUsers[:ln-1]
		break
	}
	return nil
}

// SetLastUpdatedByUser of the user to the related item.
// Sets o.R.LastUpdatedByUser to related.
// Adds o to related.R.LastUpdatedByUsers.
func (o *User) SetLastUpdatedByUser(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"users\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"last_updated_by"}),
		strmangle.WhereClause("\"", "\"", 2, userPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.LastUpdatedBy, related.ID)
	if o.R == nil {
		o.R = &userR{
			LastUpdatedByUser: related,
		}
	} else {
		o.R.LastUpdatedByUser = related
	}

	if related.R == nil {
		related.R = &userR{
			LastUpdatedByUsers: UserSlice{o},
		}
	} else {
		related.R.LastUpdatedByUsers = append(related.R.LastUpdatedByUsers, o)
	}

	return nil
}

// RemoveLastUpdatedByUser relationship.
// Sets o.R.LastUpdatedByUser to nil.
// Removes o from all passed in related items' relationships struct.
func (o *User) RemoveLastUpdatedByUser(ctx context.Context, exec boil.ContextExecutor, related *User) error {
	var err error

	queries.SetScanner(&o.LastUpdatedBy, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("last_updated_by")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.LastUpdatedByUser = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.LastUpdatedByUsers {
		if queries.Equal(o.LastUpdatedBy, ri.LastUpdatedBy) {
			continue
		}

		ln := len(related.R.LastUpdatedByUsers)
		if ln > 1 && i < ln-1 {
			related.R.LastUpdatedByUsers[i] = related.R.LastUpdatedByUsers[ln-1]
		}
		related.R.LastUpdatedByUsers = related.R.LastUpdatedByUsers[:ln-1]
		break
	}
	return nil
}

// SetUserInviteCodeRef of the user to the related item.
// Sets o.R.UserInviteCodeRef to related.
// Adds o to related.R.UserInviteCodeRefUsers.
func (o *User) SetUserInviteCodeRef(ctx context.Context, exec boil.ContextExecutor, insert bool, related *UserInviteCode) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"users\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"user_invite_code_ref_id"}),
		strmangle.WhereClause("\"", "\"", 2, userPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.UserInviteCodeRefID, related.ID)
	if o.R == nil {
		o.R = &userR{
			UserInviteCodeRef: related,
		}
	} else {
		o.R.UserInviteCodeRef = related
	}

	if related.R == nil {
		related.R = &userInviteCodeR{
			UserInviteCodeRefUsers: UserSlice{o},
		}
	} else {
		related.R.UserInviteCodeRefUsers = append(related.R.UserInviteCodeRefUsers, o)
	}

	return nil
}

// RemoveUserInviteCodeRef relationship.
// Sets o.R.UserInviteCodeRef to nil.
// Removes o from all passed in related items' relationships struct.
func (o *User) RemoveUserInviteCodeRef(ctx context.Context, exec boil.ContextExecutor, related *UserInviteCode) error {
	var err error

	queries.SetScanner(&o.UserInviteCodeRefID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("user_invite_code_ref_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.UserInviteCodeRef = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.UserInviteCodeRefUsers {
		if queries.Equal(o.UserInviteCodeRefID, ri.UserInviteCodeRefID) {
			continue
		}

		ln := len(related.R.UserInviteCodeRefUsers)
		if ln > 1 && i < ln-1 {
			related.R.UserInviteCodeRefUsers[i] = related.R.UserInviteCodeRefUsers[ln-1]
		}
		related.R.UserInviteCodeRefUsers = related.R.UserInviteCodeRefUsers[:ln-1]
		break
	}
	return nil
}

// SetUserRefWingsEcnUserTotal of the user to the related item.
// Sets o.R.UserRefWingsEcnUserTotal to related.
// Adds o to related.R.UserRef.
func (o *User) SetUserRefWingsEcnUserTotal(ctx context.Context, exec boil.ContextExecutor, insert bool, related *WingsEcnUserTotal) error {
	var err error

	if insert {
		related.UserRefID = o.ID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"wings_ecn_user_totals\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"user_ref_id"}),
			strmangle.WhereClause("\"", "\"", 2, wingsEcnUserTotalPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.ID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.UserRefID = o.ID
	}

	if o.R == nil {
		o.R = &userR{
			UserRefWingsEcnUserTotal: related,
		}
	} else {
		o.R.UserRefWingsEcnUserTotal = related
	}

	if related.R == nil {
		related.R = &wingsEcnUserTotalR{
			UserRef: o,
		}
	} else {
		related.R.UserRef = o
	}
	return nil
}

// AddUserRefAgentLogs adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserRefAgentLogs.
// Sets related.R.UserRef appropriately.
func (o *User) AddUserRefAgentLogs(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AgentLog) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserRefID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"agent_log\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_ref_id"}),
				strmangle.WhereClause("\"", "\"", 2, agentLogPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserRefID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserRefAgentLogs: related,
		}
	} else {
		o.R.UserRefAgentLogs = append(o.R.UserRefAgentLogs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &agentLogR{
				UserRef: o,
			}
		} else {
			rel.R.UserRef = o
		}
	}
	return nil
}

// AddUserRefDateInstanceLogs adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserRefDateInstanceLogs.
// Sets related.R.UserRef appropriately.
func (o *User) AddUserRefDateInstanceLogs(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DateInstanceLog) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.UserRefID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"date_instance_log\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_ref_id"}),
				strmangle.WhereClause("\"", "\"", 2, dateInstanceLogPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.UserRefID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserRefDateInstanceLogs: related,
		}
	} else {
		o.R.UserRefDateInstanceLogs = append(o.R.UserRefDateInstanceLogs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dateInstanceLogR{
				UserRef: o,
			}
		} else {
			rel.R.UserRef = o
		}
	}
	return nil
}

// SetUserRefDateInstanceLogs removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.UserRef's UserRefDateInstanceLogs accordingly.
// Replaces o.R.UserRefDateInstanceLogs with related.
// Sets related.R.UserRef's UserRefDateInstanceLogs accordingly.
func (o *User) SetUserRefDateInstanceLogs(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DateInstanceLog) error {
	query := "update \"date_instance_log\" set \"user_ref_id\" = null where \"user_ref_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.UserRefDateInstanceLogs {
			queries.SetScanner(&rel.UserRefID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.UserRef = nil
		}
		o.R.UserRefDateInstanceLogs = nil
	}

	return o.AddUserRefDateInstanceLogs(ctx, exec, insert, related...)
}

// RemoveUserRefDateInstanceLogs relationships from objects passed in.
// Removes related items from R.UserRefDateInstanceLogs (uses pointer comparison, removal does not keep order)
// Sets related.R.UserRef.
func (o *User) RemoveUserRefDateInstanceLogs(ctx context.Context, exec boil.ContextExecutor, related ...*DateInstanceLog) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.UserRefID, nil)
		if rel.R != nil {
			rel.R.UserRef = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("user_ref_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.UserRefDateInstanceLogs {
			if rel != ri {
				continue
			}

			ln := len(o.R.UserRefDateInstanceLogs)
			if ln > 1 && i < ln-1 {
				o.R.UserRefDateInstanceLogs[i] = o.R.UserRefDateInstanceLogs[ln-1]
			}
			o.R.UserRefDateInstanceLogs = o.R.UserRefDateInstanceLogs[:ln-1]
			break
		}
	}

	return nil
}

// AddSuggestedByRefDateInstanceProposals adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.SuggestedByRefDateInstanceProposals.
// Sets related.R.SuggestedByRef appropriately.
func (o *User) AddSuggestedByRefDateInstanceProposals(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DateInstanceProposal) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.SuggestedByRefID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"date_instance_proposal\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"suggested_by_ref_id"}),
				strmangle.WhereClause("\"", "\"", 2, dateInstanceProposalPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.SuggestedByRefID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			SuggestedByRefDateInstanceProposals: related,
		}
	} else {
		o.R.SuggestedByRefDateInstanceProposals = append(o.R.SuggestedByRefDateInstanceProposals, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dateInstanceProposalR{
				SuggestedByRef: o,
			}
		} else {
			rel.R.SuggestedByRef = o
		}
	}
	return nil
}

// AddSenderMatchChatMessages adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.SenderMatchChatMessages.
// Sets related.R.Sender appropriately.
func (o *User) AddSenderMatchChatMessages(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MatchChatMessage) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.SenderID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"match_chat_message\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"sender_id"}),
				strmangle.WhereClause("\"", "\"", 2, matchChatMessagePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.SenderID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			SenderMatchChatMessages: related,
		}
	} else {
		o.R.SenderMatchChatMessages = append(o.R.SenderMatchChatMessages, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &matchChatMessageR{
				Sender: o,
			}
		} else {
			rel.R.Sender = o
		}
	}
	return nil
}

// AddInitiatorUserRefMatchResults adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.InitiatorUserRefMatchResults.
// Sets related.R.InitiatorUserRef appropriately.
func (o *User) AddInitiatorUserRefMatchResults(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MatchResult) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.InitiatorUserRefID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"match_result\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"initiator_user_ref_id"}),
				strmangle.WhereClause("\"", "\"", 2, matchResultPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.InitiatorUserRefID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			InitiatorUserRefMatchResults: related,
		}
	} else {
		o.R.InitiatorUserRefMatchResults = append(o.R.InitiatorUserRefMatchResults, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &matchResultR{
				InitiatorUserRef: o,
			}
		} else {
			rel.R.InitiatorUserRef = o
		}
	}
	return nil
}

// AddReceiverUserRefMatchResults adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.ReceiverUserRefMatchResults.
// Sets related.R.ReceiverUserRef appropriately.
func (o *User) AddReceiverUserRefMatchResults(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MatchResult) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ReceiverUserRefID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"match_result\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"receiver_user_ref_id"}),
				strmangle.WhereClause("\"", "\"", 2, matchResultPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ReceiverUserRefID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			ReceiverUserRefMatchResults: related,
		}
	} else {
		o.R.ReceiverUserRefMatchResults = append(o.R.ReceiverUserRefMatchResults, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &matchResultR{
				ReceiverUserRef: o,
			}
		} else {
			rel.R.ReceiverUserRef = o
		}
	}
	return nil
}

// AddUserARefMatchResults adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserARefMatchResults.
// Sets related.R.UserARef appropriately.
func (o *User) AddUserARefMatchResults(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MatchResult) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.InitiatorUserRefID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"match_result\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"initiator_user_ref_id"}),
				strmangle.WhereClause("\"", "\"", 2, matchResultPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.InitiatorUserRefID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserARefMatchResults: related,
		}
	} else {
		o.R.UserARefMatchResults = append(o.R.UserARefMatchResults, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &matchResultR{
				UserARef: o,
			}
		} else {
			rel.R.UserARef = o
		}
	}
	return nil
}

// AddUserBRefMatchResults adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserBRefMatchResults.
// Sets related.R.UserBRef appropriately.
func (o *User) AddUserBRefMatchResults(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MatchResult) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ReceiverUserRefID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"match_result\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"receiver_user_ref_id"}),
				strmangle.WhereClause("\"", "\"", 2, matchResultPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ReceiverUserRefID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserBRefMatchResults: related,
		}
	} else {
		o.R.UserBRefMatchResults = append(o.R.UserBRefMatchResults, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &matchResultR{
				UserBRef: o,
			}
		} else {
			rel.R.UserBRef = o
		}
	}
	return nil
}

// AddUserRefNotifications adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserRefNotifications.
// Sets related.R.UserRef appropriately.
func (o *User) AddUserRefNotifications(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Notification) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserRefID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"notification\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_ref_id"}),
				strmangle.WhereClause("\"", "\"", 2, notificationPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserRefID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserRefNotifications: related,
		}
	} else {
		o.R.UserRefNotifications = append(o.R.UserRefNotifications, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &notificationR{
				UserRef: o,
			}
		} else {
			rel.R.UserRef = o
		}
	}
	return nil
}

// AddUserRefSchedulingCards adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserRefSchedulingCards.
// Sets related.R.UserRef appropriately.
func (o *User) AddUserRefSchedulingCards(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*SchedulingCard) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserRefID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"scheduling_card\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_ref_id"}),
				strmangle.WhereClause("\"", "\"", 2, schedulingCardPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserRefID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserRefSchedulingCards: related,
		}
	} else {
		o.R.UserRefSchedulingCards = append(o.R.UserRefSchedulingCards, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &schedulingCardR{
				UserRef: o,
			}
		} else {
			rel.R.UserRef = o
		}
	}
	return nil
}

// AddUserAiContexts adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserAiContexts.
// Sets related.R.User appropriately.
func (o *User) AddUserAiContexts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserAiContext) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_ai_context\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, userAiContextPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserAiContexts: related,
		}
	} else {
		o.R.UserAiContexts = append(o.R.UserAiContexts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userAiContextR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddUserAiConvos adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserAiConvos.
// Sets related.R.User appropriately.
func (o *User) AddUserAiConvos(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserAIConvo) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_ai_convo\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, UserAIConvoPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserAiConvos: related,
		}
	} else {
		o.R.UserAiConvos = append(o.R.UserAiConvos, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &UserAIConvoR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddUserAvailabilities adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserAvailabilities.
// Sets related.R.User appropriately.
func (o *User) AddUserAvailabilities(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserAvailability) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_availability\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, userAvailabilityPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserAvailabilities: related,
		}
	} else {
		o.R.UserAvailabilities = append(o.R.UserAvailabilities, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userAvailabilityR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddUserBlockedContacts adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserBlockedContacts.
// Sets related.R.User appropriately.
func (o *User) AddUserBlockedContacts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserBlockedContact) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_blocked_contact\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, userBlockedContactPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserBlockedContacts: related,
		}
	} else {
		o.R.UserBlockedContacts = append(o.R.UserBlockedContacts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userBlockedContactR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddUserDateTypePreferences adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserDateTypePreferences.
// Sets related.R.User appropriately.
func (o *User) AddUserDateTypePreferences(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserDateTypePreference) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_date_type_preference\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, userDateTypePreferencePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserDateTypePreferences: related,
		}
	} else {
		o.R.UserDateTypePreferences = append(o.R.UserDateTypePreferences, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userDateTypePreferenceR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddUserDatingPreferences adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserDatingPreferences.
// Sets related.R.User appropriately.
func (o *User) AddUserDatingPreferences(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserDatingPreference) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_dating_preferences\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, userDatingPreferencePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserDatingPreferences: related,
		}
	} else {
		o.R.UserDatingPreferences = append(o.R.UserDatingPreferences, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userDatingPreferenceR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddUserDietaryRestrictions adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserDietaryRestrictions.
// Sets related.R.User appropriately.
func (o *User) AddUserDietaryRestrictions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserDietaryRestriction) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_dietary_restriction\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, userDietaryRestrictionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserDietaryRestrictions: related,
		}
	} else {
		o.R.UserDietaryRestrictions = append(o.R.UserDietaryRestrictions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userDietaryRestrictionR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddUserElevenLabs adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserElevenLabs.
// Sets related.R.User appropriately.
func (o *User) AddUserElevenLabs(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserElevenLab) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_eleven_labs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, userElevenLabPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserElevenLabs: related,
		}
	} else {
		o.R.UserElevenLabs = append(o.R.UserElevenLabs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userElevenLabR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddUserMobilityConstraints adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserMobilityConstraints.
// Sets related.R.User appropriately.
func (o *User) AddUserMobilityConstraints(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserMobilityConstraint) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_mobility_constraint\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, userMobilityConstraintPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserMobilityConstraints: related,
		}
	} else {
		o.R.UserMobilityConstraints = append(o.R.UserMobilityConstraints, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userMobilityConstraintR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddUserPhotos adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserPhotos.
// Sets related.R.User appropriately.
func (o *User) AddUserPhotos(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserPhoto) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_photo\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, userPhotoPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserPhotos: related,
		}
	} else {
		o.R.UserPhotos = append(o.R.UserPhotos, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userPhotoR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// AddCreatedByUsers adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.CreatedByUsers.
// Sets related.R.CreatedByUser appropriately.
func (o *User) AddCreatedByUsers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*User) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.CreatedBy, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"users\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"created_by"}),
				strmangle.WhereClause("\"", "\"", 2, userPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.CreatedBy, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			CreatedByUsers: related,
		}
	} else {
		o.R.CreatedByUsers = append(o.R.CreatedByUsers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userR{
				CreatedByUser: o,
			}
		} else {
			rel.R.CreatedByUser = o
		}
	}
	return nil
}

// SetCreatedByUsers removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.CreatedByUser's CreatedByUsers accordingly.
// Replaces o.R.CreatedByUsers with related.
// Sets related.R.CreatedByUser's CreatedByUsers accordingly.
func (o *User) SetCreatedByUsers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*User) error {
	query := "update \"users\" set \"created_by\" = null where \"created_by\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.CreatedByUsers {
			queries.SetScanner(&rel.CreatedBy, nil)
			if rel.R == nil {
				continue
			}

			rel.R.CreatedByUser = nil
		}
		o.R.CreatedByUsers = nil
	}

	return o.AddCreatedByUsers(ctx, exec, insert, related...)
}

// RemoveCreatedByUsers relationships from objects passed in.
// Removes related items from R.CreatedByUsers (uses pointer comparison, removal does not keep order)
// Sets related.R.CreatedByUser.
func (o *User) RemoveCreatedByUsers(ctx context.Context, exec boil.ContextExecutor, related ...*User) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.CreatedBy, nil)
		if rel.R != nil {
			rel.R.CreatedByUser = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("created_by")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.CreatedByUsers {
			if rel != ri {
				continue
			}

			ln := len(o.R.CreatedByUsers)
			if ln > 1 && i < ln-1 {
				o.R.CreatedByUsers[i] = o.R.CreatedByUsers[ln-1]
			}
			o.R.CreatedByUsers = o.R.CreatedByUsers[:ln-1]
			break
		}
	}

	return nil
}

// AddLastUpdatedByUsers adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.LastUpdatedByUsers.
// Sets related.R.LastUpdatedByUser appropriately.
func (o *User) AddLastUpdatedByUsers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*User) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.LastUpdatedBy, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"users\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"last_updated_by"}),
				strmangle.WhereClause("\"", "\"", 2, userPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.LastUpdatedBy, o.ID)
		}
	}

	if o.R == nil {
		o.R = &userR{
			LastUpdatedByUsers: related,
		}
	} else {
		o.R.LastUpdatedByUsers = append(o.R.LastUpdatedByUsers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userR{
				LastUpdatedByUser: o,
			}
		} else {
			rel.R.LastUpdatedByUser = o
		}
	}
	return nil
}

// SetLastUpdatedByUsers removes all previously related items of the
// user replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.LastUpdatedByUser's LastUpdatedByUsers accordingly.
// Replaces o.R.LastUpdatedByUsers with related.
// Sets related.R.LastUpdatedByUser's LastUpdatedByUsers accordingly.
func (o *User) SetLastUpdatedByUsers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*User) error {
	query := "update \"users\" set \"last_updated_by\" = null where \"last_updated_by\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.LastUpdatedByUsers {
			queries.SetScanner(&rel.LastUpdatedBy, nil)
			if rel.R == nil {
				continue
			}

			rel.R.LastUpdatedByUser = nil
		}
		o.R.LastUpdatedByUsers = nil
	}

	return o.AddLastUpdatedByUsers(ctx, exec, insert, related...)
}

// RemoveLastUpdatedByUsers relationships from objects passed in.
// Removes related items from R.LastUpdatedByUsers (uses pointer comparison, removal does not keep order)
// Sets related.R.LastUpdatedByUser.
func (o *User) RemoveLastUpdatedByUsers(ctx context.Context, exec boil.ContextExecutor, related ...*User) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.LastUpdatedBy, nil)
		if rel.R != nil {
			rel.R.LastUpdatedByUser = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("last_updated_by")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.LastUpdatedByUsers {
			if rel != ri {
				continue
			}

			ln := len(o.R.LastUpdatedByUsers)
			if ln > 1 && i < ln-1 {
				o.R.LastUpdatedByUsers[i] = o.R.LastUpdatedByUsers[ln-1]
			}
			o.R.LastUpdatedByUsers = o.R.LastUpdatedByUsers[:ln-1]
			break
		}
	}

	return nil
}

// AddSuggestedByRefVenueSuggestions adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.SuggestedByRefVenueSuggestions.
// Sets related.R.SuggestedByRef appropriately.
func (o *User) AddSuggestedByRefVenueSuggestions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*VenueSuggestion) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.SuggestedByRefID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"venue_suggestion\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"suggested_by_ref_id"}),
				strmangle.WhereClause("\"", "\"", 2, venueSuggestionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.SuggestedByRefID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			SuggestedByRefVenueSuggestions: related,
		}
	} else {
		o.R.SuggestedByRefVenueSuggestions = append(o.R.SuggestedByRefVenueSuggestions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &venueSuggestionR{
				SuggestedByRef: o,
			}
		} else {
			rel.R.SuggestedByRef = o
		}
	}
	return nil
}

// AddUserRefWingsEcnActionLogs adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.UserRefWingsEcnActionLogs.
// Sets related.R.UserRef appropriately.
func (o *User) AddUserRefWingsEcnActionLogs(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*WingsEcnActionLog) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserRefID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"wings_ecn_action_log\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_ref_id"}),
				strmangle.WhereClause("\"", "\"", 2, wingsEcnActionLogPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserRefID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			UserRefWingsEcnActionLogs: related,
		}
	} else {
		o.R.UserRefWingsEcnActionLogs = append(o.R.UserRefWingsEcnActionLogs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &wingsEcnActionLogR{
				UserRef: o,
			}
		} else {
			rel.R.UserRef = o
		}
	}
	return nil
}

// AddWingsEcnUserSubscriptionPlans adds the given related objects to the existing relationships
// of the user, optionally inserting them as new records.
// Appends related to o.R.WingsEcnUserSubscriptionPlans.
// Sets related.R.User appropriately.
func (o *User) AddWingsEcnUserSubscriptionPlans(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*WingsEcnUserSubscriptionPlan) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"wings_ecn_user_subscription_plan\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
				strmangle.WhereClause("\"", "\"", 2, wingsEcnUserSubscriptionPlanPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserID = o.ID
		}
	}

	if o.R == nil {
		o.R = &userR{
			WingsEcnUserSubscriptionPlans: related,
		}
	} else {
		o.R.WingsEcnUserSubscriptionPlans = append(o.R.WingsEcnUserSubscriptionPlans, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &wingsEcnUserSubscriptionPlanR{
				User: o,
			}
		} else {
			rel.R.User = o
		}
	}
	return nil
}

// Users retrieves all the records using an executor.
func Users(mods ...qm.QueryMod) userQuery {
	mods = append(mods, qm.From("\"users\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"users\".*"})
	}

	return userQuery{q}
}

// FindUser retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindUser(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*User, error) {
	userObj := &User{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"users\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, userObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "pgmodel: unable to select from users")
	}

	if err = userObj.doAfterSelectHooks(ctx, exec); err != nil {
		return userObj, err
	}

	return userObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *User) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("pgmodel: no users provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(userColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	userInsertCacheMut.RLock()
	cache, cached := userInsertCache[key]
	userInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			userAllColumns,
			userColumnsWithDefault,
			userColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(userType, userMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(userType, userMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"users\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"users\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "pgmodel: unable to insert into users")
	}

	if !cached {
		userInsertCacheMut.Lock()
		userInsertCache[key] = cache
		userInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the User.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *User) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	userUpdateCacheMut.RLock()
	cache, cached := userUpdateCache[key]
	userUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			userAllColumns,
			userPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("pgmodel: unable to update users, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"users\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, userPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(userType, userMapping, append(wl, userPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to update users row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: failed to get rows affected by update for users")
	}

	if !cached {
		userUpdateCacheMut.Lock()
		userUpdateCache[key] = cache
		userUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q userQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to update all for users")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to retrieve rows affected for users")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o UserSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("pgmodel: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"users\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, userPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to update all in user slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to retrieve rows affected all in update all user")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *User) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("pgmodel: no users provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(userColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	userUpsertCacheMut.RLock()
	cache, cached := userUpsertCache[key]
	userUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			userAllColumns,
			userColumnsWithDefault,
			userColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			userAllColumns,
			userPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("pgmodel: unable to upsert users, could not build update column list")
		}

		ret := strmangle.SetComplement(userAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(userPrimaryKeyColumns) == 0 {
				return errors.New("pgmodel: unable to upsert users, could not build conflict column list")
			}

			conflict = make([]string, len(userPrimaryKeyColumns))
			copy(conflict, userPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"users\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(userType, userMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(userType, userMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "pgmodel: unable to upsert users")
	}

	if !cached {
		userUpsertCacheMut.Lock()
		userUpsertCache[key] = cache
		userUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single User record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *User) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("pgmodel: no User provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), userPrimaryKeyMapping)
	sql := "DELETE FROM \"users\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to delete from users")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: failed to get rows affected by delete for users")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q userQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("pgmodel: no userQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to delete all from users")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: failed to get rows affected by deleteall for users")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o UserSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(userBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"users\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, userPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to delete all from user slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: failed to get rows affected by deleteall for users")
	}

	if len(userAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *User) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindUser(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *UserSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := UserSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"users\".* FROM \"users\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, userPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "pgmodel: unable to reload all in UserSlice")
	}

	*o = slice

	return nil
}

// UserExists checks if the User row exists.
func UserExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"users\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "pgmodel: unable to check if users exists")
	}

	return exists, nil
}

// Exists checks if the User row exists.
func (o *User) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return UserExists(ctx, exec, o.ID)
}
