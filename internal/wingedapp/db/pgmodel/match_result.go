// Code generated by SQLBoiler 4.19.5 (https://github.com/aarondl/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package pgmodel

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	"github.com/aarondl/sqlboiler/v4/queries"
	"github.com/aarondl/sqlboiler/v4/queries/qm"
	"github.com/aarondl/sqlboiler/v4/queries/qmhelper"
	"github.com/aarondl/strmangle"
	"github.com/friendsofgo/errors"
)

// MatchResult is an object representing the database table.
type MatchResult struct {
	ID                    string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	MatchSetRefID         string      `boil:"match_set_ref_id" json:"match_set_ref_id" toml:"match_set_ref_id" yaml:"match_set_ref_id"`
	InitiatorUserRefID    string      `boil:"initiator_user_ref_id" json:"initiator_user_ref_id" toml:"initiator_user_ref_id" yaml:"initiator_user_ref_id"`
	ReceiverUserRefID     string      `boil:"receiver_user_ref_id" json:"receiver_user_ref_id" toml:"receiver_user_ref_id" yaml:"receiver_user_ref_id"`
	MatchStatus           string      `boil:"match_status" json:"match_status" toml:"match_status" yaml:"match_status"`
	MatchLifecycleStatus  null.String `boil:"match_lifecycle_status" json:"match_lifecycle_status,omitempty" toml:"match_lifecycle_status" yaml:"match_lifecycle_status,omitempty"`
	CurrentDateInstanceID null.String `boil:"current_date_instance_id" json:"current_date_instance_id,omitempty" toml:"current_date_instance_id" yaml:"current_date_instance_id,omitempty"`
	InitiatorAction           string      `boil:"initiator_action" json:"initiator_action" toml:"initiator_action" yaml:"initiator_action"`
	InitiatorActionAt         null.Time   `boil:"initiator_action_at" json:"initiator_action_at,omitempty" toml:"initiator_action_at" yaml:"initiator_action_at,omitempty"`
	InitiatorSeenAt           null.Time   `boil:"initiator_seen_at" json:"initiator_seen_at,omitempty" toml:"initiator_seen_at" yaml:"initiator_seen_at,omitempty"`
	ReceiverAction           string      `boil:"receiver_action" json:"receiver_action" toml:"receiver_action" yaml:"receiver_action"`
	ReceiverActionAt         null.Time   `boil:"receiver_action_at" json:"receiver_action_at,omitempty" toml:"receiver_action_at" yaml:"receiver_action_at,omitempty"`
	ReceiverSeenAt           null.Time   `boil:"receiver_seen_at" json:"receiver_seen_at,omitempty" toml:"receiver_seen_at" yaml:"receiver_seen_at,omitempty"`
	QualifierResults      null.JSON   `boil:"qualifier_results" json:"qualifier_results,omitempty" toml:"qualifier_results" yaml:"qualifier_results,omitempty"`
	MatchedQualitatively  bool        `boil:"matched_qualitatively" json:"matched_qualitatively" toml:"matched_qualitatively" yaml:"matched_qualitatively"`
	DeliveredToUserAt     null.Time   `boil:"delivered_to_user_at" json:"delivered_to_user_at,omitempty" toml:"delivered_to_user_at" yaml:"delivered_to_user_at,omitempty"`
	LastProposerUserRefID null.String `boil:"last_proposer_user_ref_id" json:"last_proposer_user_ref_id,omitempty" toml:"last_proposer_user_ref_id" yaml:"last_proposer_user_ref_id,omitempty"`
	LastProposedAt        null.Time   `boil:"last_proposed_at" json:"last_proposed_at,omitempty" toml:"last_proposed_at" yaml:"last_proposed_at,omitempty"`
	ChatUnlockedAt        null.Time   `boil:"chat_unlocked_at" json:"chat_unlocked_at,omitempty" toml:"chat_unlocked_at" yaml:"chat_unlocked_at,omitempty"`
	IsApproved            bool        `boil:"is_approved" json:"is_approved" toml:"is_approved" yaml:"is_approved"`
	IsDropped             bool        `boil:"is_dropped" json:"is_dropped" toml:"is_dropped" yaml:"is_dropped"`
	DroppedTS             null.Time   `boil:"dropped_ts" json:"dropped_ts,omitempty" toml:"dropped_ts" yaml:"dropped_ts,omitempty"`
	IsPossibleMatch       bool        `boil:"is_possible_match" json:"is_possible_match" toml:"is_possible_match" yaml:"is_possible_match"`
	IsExpired             bool        `boil:"is_expired" json:"is_expired" toml:"is_expired" yaml:"is_expired"`
	ExpiresAt             null.Time   `boil:"expires_at" json:"expires_at,omitempty" toml:"expires_at" yaml:"expires_at,omitempty"`
	CreatedAt             time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt             null.Time   `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`

	R *matchResultR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L matchResultL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var MatchResultColumns = struct {
	ID                    string
	MatchSetRefID         string
	InitiatorUserRefID    string
	ReceiverUserRefID     string
	MatchStatus           string
	MatchLifecycleStatus  string
	CurrentDateInstanceID string
	InitiatorAction           string
	InitiatorActionAt         string
	InitiatorSeenAt           string
	ReceiverAction           string
	ReceiverActionAt         string
	ReceiverSeenAt           string
	QualifierResults      string
	MatchedQualitatively  string
	DeliveredToUserAt     string
	LastProposerUserRefID string
	LastProposedAt        string
	ChatUnlockedAt        string
	IsApproved            string
	IsDropped             string
	DroppedTS             string
	IsPossibleMatch       string
	IsExpired             string
	ExpiresAt             string
	CreatedAt             string
	UpdatedAt             string
}{
	ID:                    "id",
	MatchSetRefID:         "match_set_ref_id",
	InitiatorUserRefID:    "initiator_user_ref_id",
	ReceiverUserRefID:     "receiver_user_ref_id",
	MatchStatus:           "match_status",
	MatchLifecycleStatus:  "match_lifecycle_status",
	CurrentDateInstanceID: "current_date_instance_id",
	InitiatorAction:           "initiator_action",
	InitiatorActionAt:         "initiator_action_at",
	InitiatorSeenAt:           "initiator_seen_at",
	ReceiverAction:           "receiver_action",
	ReceiverActionAt:         "receiver_action_at",
	ReceiverSeenAt:           "receiver_seen_at",
	QualifierResults:      "qualifier_results",
	MatchedQualitatively:  "matched_qualitatively",
	DeliveredToUserAt:     "delivered_to_user_at",
	LastProposerUserRefID: "last_proposer_user_ref_id",
	LastProposedAt:        "last_proposed_at",
	ChatUnlockedAt:        "chat_unlocked_at",
	IsApproved:            "is_approved",
	IsDropped:             "is_dropped",
	DroppedTS:             "dropped_ts",
	IsPossibleMatch:       "is_possible_match",
	IsExpired:             "is_expired",
	ExpiresAt:             "expires_at",
	CreatedAt:             "created_at",
	UpdatedAt:             "updated_at",
}

var MatchResultTableColumns = struct {
	ID                    string
	MatchSetRefID         string
	InitiatorUserRefID    string
	ReceiverUserRefID     string
	MatchStatus           string
	MatchLifecycleStatus  string
	CurrentDateInstanceID string
	InitiatorAction           string
	InitiatorActionAt         string
	InitiatorSeenAt           string
	ReceiverAction           string
	ReceiverActionAt         string
	ReceiverSeenAt           string
	QualifierResults      string
	MatchedQualitatively  string
	DeliveredToUserAt     string
	LastProposerUserRefID string
	LastProposedAt        string
	ChatUnlockedAt        string
	IsApproved            string
	IsDropped             string
	DroppedTS             string
	IsPossibleMatch       string
	IsExpired             string
	ExpiresAt             string
	CreatedAt             string
	UpdatedAt             string
}{
	ID:                    "match_result.id",
	MatchSetRefID:         "match_result.match_set_ref_id",
	InitiatorUserRefID:    "match_result.initiator_user_ref_id",
	ReceiverUserRefID:     "match_result.receiver_user_ref_id",
	MatchStatus:           "match_result.match_status",
	MatchLifecycleStatus:  "match_result.match_lifecycle_status",
	CurrentDateInstanceID: "match_result.current_date_instance_id",
	InitiatorAction:           "match_result.initiator_action",
	InitiatorActionAt:         "match_result.initiator_action_at",
	InitiatorSeenAt:           "match_result.initiator_seen_at",
	ReceiverAction:           "match_result.receiver_action",
	ReceiverActionAt:         "match_result.receiver_action_at",
	ReceiverSeenAt:           "match_result.receiver_seen_at",
	QualifierResults:      "match_result.qualifier_results",
	MatchedQualitatively:  "match_result.matched_qualitatively",
	DeliveredToUserAt:     "match_result.delivered_to_user_at",
	LastProposerUserRefID: "match_result.last_proposer_user_ref_id",
	LastProposedAt:        "match_result.last_proposed_at",
	ChatUnlockedAt:        "match_result.chat_unlocked_at",
	IsApproved:            "match_result.is_approved",
	IsDropped:             "match_result.is_dropped",
	DroppedTS:             "match_result.dropped_ts",
	IsPossibleMatch:       "match_result.is_possible_match",
	IsExpired:             "match_result.is_expired",
	ExpiresAt:             "match_result.expires_at",
	CreatedAt:             "match_result.created_at",
	UpdatedAt:             "match_result.updated_at",
}

// Generated where

type whereHelperbool struct{ field string }

func (w whereHelperbool) EQ(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperbool) NEQ(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperbool) LT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperbool) LTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperbool) GT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperbool) GTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

var MatchResultWhere = struct {
	ID                    whereHelperstring
	MatchSetRefID         whereHelperstring
	InitiatorUserRefID    whereHelperstring
	ReceiverUserRefID     whereHelperstring
	MatchStatus           whereHelperstring
	MatchLifecycleStatus  whereHelpernull_String
	CurrentDateInstanceID whereHelpernull_String
	InitiatorAction           whereHelperstring
	InitiatorActionAt         whereHelpernull_Time
	InitiatorSeenAt           whereHelpernull_Time
	ReceiverAction           whereHelperstring
	ReceiverActionAt         whereHelpernull_Time
	ReceiverSeenAt           whereHelpernull_Time
	QualifierResults      whereHelpernull_JSON
	MatchedQualitatively  whereHelperbool
	DeliveredToUserAt     whereHelpernull_Time
	LastProposerUserRefID whereHelpernull_String
	LastProposedAt        whereHelpernull_Time
	ChatUnlockedAt        whereHelpernull_Time
	IsApproved            whereHelperbool
	IsDropped             whereHelperbool
	DroppedTS             whereHelpernull_Time
	IsPossibleMatch       whereHelperbool
	IsExpired             whereHelperbool
	ExpiresAt             whereHelpernull_Time
	CreatedAt             whereHelpertime_Time
	UpdatedAt             whereHelpernull_Time
}{
	ID:                    whereHelperstring{field: "\"match_result\".\"id\""},
	MatchSetRefID:         whereHelperstring{field: "\"match_result\".\"match_set_ref_id\""},
	InitiatorUserRefID:    whereHelperstring{field: "\"match_result\".\"initiator_user_ref_id\""},
	ReceiverUserRefID:     whereHelperstring{field: "\"match_result\".\"receiver_user_ref_id\""},
	MatchStatus:           whereHelperstring{field: "\"match_result\".\"match_status\""},
	MatchLifecycleStatus:  whereHelpernull_String{field: "\"match_result\".\"match_lifecycle_status\""},
	CurrentDateInstanceID: whereHelpernull_String{field: "\"match_result\".\"current_date_instance_id\""},
	InitiatorAction:           whereHelperstring{field: "\"match_result\".\"initiator_action\""},
	InitiatorActionAt:         whereHelpernull_Time{field: "\"match_result\".\"initiator_action_at\""},
	InitiatorSeenAt:           whereHelpernull_Time{field: "\"match_result\".\"initiator_seen_at\""},
	ReceiverAction:           whereHelperstring{field: "\"match_result\".\"receiver_action\""},
	ReceiverActionAt:         whereHelpernull_Time{field: "\"match_result\".\"receiver_action_at\""},
	ReceiverSeenAt:           whereHelpernull_Time{field: "\"match_result\".\"receiver_seen_at\""},
	QualifierResults:      whereHelpernull_JSON{field: "\"match_result\".\"qualifier_results\""},
	MatchedQualitatively:  whereHelperbool{field: "\"match_result\".\"matched_qualitatively\""},
	DeliveredToUserAt:     whereHelpernull_Time{field: "\"match_result\".\"delivered_to_user_at\""},
	LastProposerUserRefID: whereHelpernull_String{field: "\"match_result\".\"last_proposer_user_ref_id\""},
	LastProposedAt:        whereHelpernull_Time{field: "\"match_result\".\"last_proposed_at\""},
	ChatUnlockedAt:        whereHelpernull_Time{field: "\"match_result\".\"chat_unlocked_at\""},
	IsApproved:            whereHelperbool{field: "\"match_result\".\"is_approved\""},
	IsDropped:             whereHelperbool{field: "\"match_result\".\"is_dropped\""},
	DroppedTS:             whereHelpernull_Time{field: "\"match_result\".\"dropped_ts\""},
	IsPossibleMatch:       whereHelperbool{field: "\"match_result\".\"is_possible_match\""},
	IsExpired:             whereHelperbool{field: "\"match_result\".\"is_expired\""},
	ExpiresAt:             whereHelpernull_Time{field: "\"match_result\".\"expires_at\""},
	CreatedAt:             whereHelpertime_Time{field: "\"match_result\".\"created_at\""},
	UpdatedAt:             whereHelpernull_Time{field: "\"match_result\".\"updated_at\""},
}

// MatchResultRels is where relationship names are stored.
var MatchResultRels = struct {
	CurrentDateInstance         string
	InitiatorUserRef            string
	MatchSetRef                 string
	ReceiverUserRef             string
	UserARef                    string
	UserBRef                    string
	MatchResultRefDateInstances string
	MatchChatMessages           string
}{
	CurrentDateInstance:         "CurrentDateInstance",
	InitiatorUserRef:            "InitiatorUserRef",
	MatchSetRef:                 "MatchSetRef",
	ReceiverUserRef:             "ReceiverUserRef",
	UserARef:                    "UserARef",
	UserBRef:                    "UserBRef",
	MatchResultRefDateInstances: "MatchResultRefDateInstances",
	MatchChatMessages:           "MatchChatMessages",
}

// matchResultR is where relationships are stored.
type matchResultR struct {
	CurrentDateInstance         *DateInstance         `boil:"CurrentDateInstance" json:"CurrentDateInstance" toml:"CurrentDateInstance" yaml:"CurrentDateInstance"`
	InitiatorUserRef            *User                 `boil:"InitiatorUserRef" json:"InitiatorUserRef" toml:"InitiatorUserRef" yaml:"InitiatorUserRef"`
	MatchSetRef                 *MatchSet             `boil:"MatchSetRef" json:"MatchSetRef" toml:"MatchSetRef" yaml:"MatchSetRef"`
	ReceiverUserRef             *User                 `boil:"ReceiverUserRef" json:"ReceiverUserRef" toml:"ReceiverUserRef" yaml:"ReceiverUserRef"`
	UserARef                    *User                 `boil:"UserARef" json:"UserARef" toml:"UserARef" yaml:"UserARef"`
	UserBRef                    *User                 `boil:"UserBRef" json:"UserBRef" toml:"UserBRef" yaml:"UserBRef"`
	MatchResultRefDateInstances DateInstanceSlice     `boil:"MatchResultRefDateInstances" json:"MatchResultRefDateInstances" toml:"MatchResultRefDateInstances" yaml:"MatchResultRefDateInstances"`
	MatchChatMessages           MatchChatMessageSlice `boil:"MatchChatMessages" json:"MatchChatMessages" toml:"MatchChatMessages" yaml:"MatchChatMessages"`
}

// NewStruct creates a new relationship struct
func (*matchResultR) NewStruct() *matchResultR {
	return &matchResultR{}
}

func (o *MatchResult) GetCurrentDateInstance() *DateInstance {
	if o == nil {
		return nil
	}

	return o.R.GetCurrentDateInstance()
}

func (r *matchResultR) GetCurrentDateInstance() *DateInstance {
	if r == nil {
		return nil
	}

	return r.CurrentDateInstance
}

func (o *MatchResult) GetInitiatorUserRef() *User {
	if o == nil {
		return nil
	}

	return o.R.GetInitiatorUserRef()
}

func (r *matchResultR) GetInitiatorUserRef() *User {
	if r == nil {
		return nil
	}

	return r.InitiatorUserRef
}

func (o *MatchResult) GetMatchSetRef() *MatchSet {
	if o == nil {
		return nil
	}

	return o.R.GetMatchSetRef()
}

func (r *matchResultR) GetMatchSetRef() *MatchSet {
	if r == nil {
		return nil
	}

	return r.MatchSetRef
}

func (o *MatchResult) GetReceiverUserRef() *User {
	if o == nil {
		return nil
	}

	return o.R.GetReceiverUserRef()
}

func (r *matchResultR) GetReceiverUserRef() *User {
	if r == nil {
		return nil
	}

	return r.ReceiverUserRef
}

func (o *MatchResult) GetUserARef() *User {
	if o == nil {
		return nil
	}

	return o.R.GetUserARef()
}

func (r *matchResultR) GetUserARef() *User {
	if r == nil {
		return nil
	}

	return r.UserARef
}

func (o *MatchResult) GetUserBRef() *User {
	if o == nil {
		return nil
	}

	return o.R.GetUserBRef()
}

func (r *matchResultR) GetUserBRef() *User {
	if r == nil {
		return nil
	}

	return r.UserBRef
}

func (o *MatchResult) GetMatchResultRefDateInstances() DateInstanceSlice {
	if o == nil {
		return nil
	}

	return o.R.GetMatchResultRefDateInstances()
}

func (r *matchResultR) GetMatchResultRefDateInstances() DateInstanceSlice {
	if r == nil {
		return nil
	}

	return r.MatchResultRefDateInstances
}

func (o *MatchResult) GetMatchChatMessages() MatchChatMessageSlice {
	if o == nil {
		return nil
	}

	return o.R.GetMatchChatMessages()
}

func (r *matchResultR) GetMatchChatMessages() MatchChatMessageSlice {
	if r == nil {
		return nil
	}

	return r.MatchChatMessages
}

// matchResultL is where Load methods for each relationship are stored.
type matchResultL struct{}

var (
	matchResultAllColumns            = []string{"id", "match_set_ref_id", "initiator_user_ref_id", "receiver_user_ref_id", "match_status", "match_lifecycle_status", "current_date_instance_id", "initiator_action", "initiator_action_at", "initiator_seen_at", "receiver_action", "receiver_action_at", "receiver_seen_at", "qualifier_results", "matched_qualitatively", "delivered_to_user_at", "last_proposer_user_ref_id", "last_proposed_at", "chat_unlocked_at", "is_approved", "is_dropped", "dropped_ts", "is_possible_match", "is_expired", "expires_at", "created_at", "updated_at"}
	matchResultColumnsWithoutDefault = []string{"match_set_ref_id", "initiator_user_ref_id", "receiver_user_ref_id"}
	matchResultColumnsWithDefault    = []string{"id", "match_status", "match_lifecycle_status", "current_date_instance_id", "initiator_action", "initiator_action_at", "initiator_seen_at", "receiver_action", "receiver_action_at", "receiver_seen_at", "qualifier_results", "matched_qualitatively", "delivered_to_user_at", "last_proposer_user_ref_id", "last_proposed_at", "chat_unlocked_at", "is_approved", "is_dropped", "dropped_ts", "is_possible_match", "is_expired", "expires_at", "created_at", "updated_at"}
	matchResultPrimaryKeyColumns     = []string{"id"}
	matchResultGeneratedColumns      = []string{}
)

type (
	// MatchResultSlice is an alias for a slice of pointers to MatchResult.
	// This should almost always be used instead of []MatchResult.
	MatchResultSlice []*MatchResult
	// MatchResultHook is the signature for custom MatchResult hook methods
	MatchResultHook func(context.Context, boil.ContextExecutor, *MatchResult) error

	matchResultQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	matchResultType                 = reflect.TypeOf(&MatchResult{})
	matchResultMapping              = queries.MakeStructMapping(matchResultType)
	matchResultPrimaryKeyMapping, _ = queries.BindMapping(matchResultType, matchResultMapping, matchResultPrimaryKeyColumns)
	matchResultInsertCacheMut       sync.RWMutex
	matchResultInsertCache          = make(map[string]insertCache)
	matchResultUpdateCacheMut       sync.RWMutex
	matchResultUpdateCache          = make(map[string]updateCache)
	matchResultUpsertCacheMut       sync.RWMutex
	matchResultUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var matchResultAfterSelectMu sync.Mutex
var matchResultAfterSelectHooks []MatchResultHook

var matchResultBeforeInsertMu sync.Mutex
var matchResultBeforeInsertHooks []MatchResultHook
var matchResultAfterInsertMu sync.Mutex
var matchResultAfterInsertHooks []MatchResultHook

var matchResultBeforeUpdateMu sync.Mutex
var matchResultBeforeUpdateHooks []MatchResultHook
var matchResultAfterUpdateMu sync.Mutex
var matchResultAfterUpdateHooks []MatchResultHook

var matchResultBeforeDeleteMu sync.Mutex
var matchResultBeforeDeleteHooks []MatchResultHook
var matchResultAfterDeleteMu sync.Mutex
var matchResultAfterDeleteHooks []MatchResultHook

var matchResultBeforeUpsertMu sync.Mutex
var matchResultBeforeUpsertHooks []MatchResultHook
var matchResultAfterUpsertMu sync.Mutex
var matchResultAfterUpsertHooks []MatchResultHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *MatchResult) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range matchResultAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *MatchResult) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range matchResultBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *MatchResult) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range matchResultAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *MatchResult) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range matchResultBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *MatchResult) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range matchResultAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *MatchResult) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range matchResultBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *MatchResult) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range matchResultAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *MatchResult) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range matchResultBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *MatchResult) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range matchResultAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddMatchResultHook registers your hook function for all future operations.
func AddMatchResultHook(hookPoint boil.HookPoint, matchResultHook MatchResultHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		matchResultAfterSelectMu.Lock()
		matchResultAfterSelectHooks = append(matchResultAfterSelectHooks, matchResultHook)
		matchResultAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		matchResultBeforeInsertMu.Lock()
		matchResultBeforeInsertHooks = append(matchResultBeforeInsertHooks, matchResultHook)
		matchResultBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		matchResultAfterInsertMu.Lock()
		matchResultAfterInsertHooks = append(matchResultAfterInsertHooks, matchResultHook)
		matchResultAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		matchResultBeforeUpdateMu.Lock()
		matchResultBeforeUpdateHooks = append(matchResultBeforeUpdateHooks, matchResultHook)
		matchResultBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		matchResultAfterUpdateMu.Lock()
		matchResultAfterUpdateHooks = append(matchResultAfterUpdateHooks, matchResultHook)
		matchResultAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		matchResultBeforeDeleteMu.Lock()
		matchResultBeforeDeleteHooks = append(matchResultBeforeDeleteHooks, matchResultHook)
		matchResultBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		matchResultAfterDeleteMu.Lock()
		matchResultAfterDeleteHooks = append(matchResultAfterDeleteHooks, matchResultHook)
		matchResultAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		matchResultBeforeUpsertMu.Lock()
		matchResultBeforeUpsertHooks = append(matchResultBeforeUpsertHooks, matchResultHook)
		matchResultBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		matchResultAfterUpsertMu.Lock()
		matchResultAfterUpsertHooks = append(matchResultAfterUpsertHooks, matchResultHook)
		matchResultAfterUpsertMu.Unlock()
	}
}

// One returns a single matchResult record from the query.
func (q matchResultQuery) One(ctx context.Context, exec boil.ContextExecutor) (*MatchResult, error) {
	o := &MatchResult{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "pgmodel: failed to execute a one query for match_result")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all MatchResult records from the query.
func (q matchResultQuery) All(ctx context.Context, exec boil.ContextExecutor) (MatchResultSlice, error) {
	var o []*MatchResult

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "pgmodel: failed to assign all query results to MatchResult slice")
	}

	if len(matchResultAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all MatchResult records in the query.
func (q matchResultQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: failed to count match_result rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q matchResultQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "pgmodel: failed to check if match_result exists")
	}

	return count > 0, nil
}

// CurrentDateInstance pointed to by the foreign key.
func (o *MatchResult) CurrentDateInstance(mods ...qm.QueryMod) dateInstanceQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.CurrentDateInstanceID),
	}

	queryMods = append(queryMods, mods...)

	return DateInstances(queryMods...)
}

// InitiatorUserRef pointed to by the foreign key.
func (o *MatchResult) InitiatorUserRef(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.InitiatorUserRefID),
	}

	queryMods = append(queryMods, mods...)

	return Users(queryMods...)
}

// MatchSetRef pointed to by the foreign key.
func (o *MatchResult) MatchSetRef(mods ...qm.QueryMod) matchSetQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.MatchSetRefID),
	}

	queryMods = append(queryMods, mods...)

	return MatchSets(queryMods...)
}

// ReceiverUserRef pointed to by the foreign key.
func (o *MatchResult) ReceiverUserRef(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ReceiverUserRefID),
	}

	queryMods = append(queryMods, mods...)

	return Users(queryMods...)
}

// UserARef pointed to by the foreign key.
func (o *MatchResult) UserARef(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.InitiatorUserRefID),
	}

	queryMods = append(queryMods, mods...)

	return Users(queryMods...)
}

// UserBRef pointed to by the foreign key.
func (o *MatchResult) UserBRef(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ReceiverUserRefID),
	}

	queryMods = append(queryMods, mods...)

	return Users(queryMods...)
}

// MatchResultRefDateInstances retrieves all the date_instance's DateInstances with an executor via match_result_ref_id column.
func (o *MatchResult) MatchResultRefDateInstances(mods ...qm.QueryMod) dateInstanceQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"date_instance\".\"match_result_ref_id\"=?", o.ID),
	)

	return DateInstances(queryMods...)
}

// MatchChatMessages retrieves all the match_chat_message's MatchChatMessages with an executor.
func (o *MatchResult) MatchChatMessages(mods ...qm.QueryMod) matchChatMessageQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"match_chat_message\".\"match_result_id\"=?", o.ID),
	)

	return MatchChatMessages(queryMods...)
}

// LoadCurrentDateInstance allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (matchResultL) LoadCurrentDateInstance(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMatchResult interface{}, mods queries.Applicator) error {
	var slice []*MatchResult
	var object *MatchResult

	if singular {
		var ok bool
		object, ok = maybeMatchResult.(*MatchResult)
		if !ok {
			object = new(MatchResult)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatchResult)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatchResult))
			}
		}
	} else {
		s, ok := maybeMatchResult.(*[]*MatchResult)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatchResult)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatchResult))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchResultR{}
		}
		if !queries.IsNil(object.CurrentDateInstanceID) {
			args[object.CurrentDateInstanceID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchResultR{}
			}

			if !queries.IsNil(obj.CurrentDateInstanceID) {
				args[obj.CurrentDateInstanceID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`date_instance`),
		qm.WhereIn(`date_instance.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DateInstance")
	}

	var resultSlice []*DateInstance
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DateInstance")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for date_instance")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for date_instance")
	}

	if len(dateInstanceAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.CurrentDateInstance = foreign
		if foreign.R == nil {
			foreign.R = &dateInstanceR{}
		}
		foreign.R.CurrentDateInstanceMatchResults = append(foreign.R.CurrentDateInstanceMatchResults, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CurrentDateInstanceID, foreign.ID) {
				local.R.CurrentDateInstance = foreign
				if foreign.R == nil {
					foreign.R = &dateInstanceR{}
				}
				foreign.R.CurrentDateInstanceMatchResults = append(foreign.R.CurrentDateInstanceMatchResults, local)
				break
			}
		}
	}

	return nil
}

// LoadInitiatorUserRef allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (matchResultL) LoadInitiatorUserRef(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMatchResult interface{}, mods queries.Applicator) error {
	var slice []*MatchResult
	var object *MatchResult

	if singular {
		var ok bool
		object, ok = maybeMatchResult.(*MatchResult)
		if !ok {
			object = new(MatchResult)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatchResult)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatchResult))
			}
		}
	} else {
		s, ok := maybeMatchResult.(*[]*MatchResult)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatchResult)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatchResult))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchResultR{}
		}
		args[object.InitiatorUserRefID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchResultR{}
			}

			args[obj.InitiatorUserRefID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.InitiatorUserRef = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.InitiatorUserRefMatchResults = append(foreign.R.InitiatorUserRefMatchResults, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.InitiatorUserRefID == foreign.ID {
				local.R.InitiatorUserRef = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.InitiatorUserRefMatchResults = append(foreign.R.InitiatorUserRefMatchResults, local)
				break
			}
		}
	}

	return nil
}

// LoadMatchSetRef allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (matchResultL) LoadMatchSetRef(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMatchResult interface{}, mods queries.Applicator) error {
	var slice []*MatchResult
	var object *MatchResult

	if singular {
		var ok bool
		object, ok = maybeMatchResult.(*MatchResult)
		if !ok {
			object = new(MatchResult)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatchResult)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatchResult))
			}
		}
	} else {
		s, ok := maybeMatchResult.(*[]*MatchResult)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatchResult)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatchResult))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchResultR{}
		}
		args[object.MatchSetRefID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchResultR{}
			}

			args[obj.MatchSetRefID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`match_set`),
		qm.WhereIn(`match_set.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load MatchSet")
	}

	var resultSlice []*MatchSet
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice MatchSet")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for match_set")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for match_set")
	}

	if len(matchSetAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.MatchSetRef = foreign
		if foreign.R == nil {
			foreign.R = &matchSetR{}
		}
		foreign.R.MatchSetRefMatchResults = append(foreign.R.MatchSetRefMatchResults, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.MatchSetRefID == foreign.ID {
				local.R.MatchSetRef = foreign
				if foreign.R == nil {
					foreign.R = &matchSetR{}
				}
				foreign.R.MatchSetRefMatchResults = append(foreign.R.MatchSetRefMatchResults, local)
				break
			}
		}
	}

	return nil
}

// LoadReceiverUserRef allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (matchResultL) LoadReceiverUserRef(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMatchResult interface{}, mods queries.Applicator) error {
	var slice []*MatchResult
	var object *MatchResult

	if singular {
		var ok bool
		object, ok = maybeMatchResult.(*MatchResult)
		if !ok {
			object = new(MatchResult)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatchResult)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatchResult))
			}
		}
	} else {
		s, ok := maybeMatchResult.(*[]*MatchResult)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatchResult)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatchResult))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchResultR{}
		}
		args[object.ReceiverUserRefID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchResultR{}
			}

			args[obj.ReceiverUserRefID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ReceiverUserRef = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.ReceiverUserRefMatchResults = append(foreign.R.ReceiverUserRefMatchResults, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ReceiverUserRefID == foreign.ID {
				local.R.ReceiverUserRef = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.ReceiverUserRefMatchResults = append(foreign.R.ReceiverUserRefMatchResults, local)
				break
			}
		}
	}

	return nil
}

// LoadUserARef allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (matchResultL) LoadUserARef(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMatchResult interface{}, mods queries.Applicator) error {
	var slice []*MatchResult
	var object *MatchResult

	if singular {
		var ok bool
		object, ok = maybeMatchResult.(*MatchResult)
		if !ok {
			object = new(MatchResult)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatchResult)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatchResult))
			}
		}
	} else {
		s, ok := maybeMatchResult.(*[]*MatchResult)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatchResult)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatchResult))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchResultR{}
		}
		args[object.InitiatorUserRefID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchResultR{}
			}

			args[obj.InitiatorUserRefID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.UserARef = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.UserARefMatchResults = append(foreign.R.UserARefMatchResults, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.InitiatorUserRefID == foreign.ID {
				local.R.UserARef = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.UserARefMatchResults = append(foreign.R.UserARefMatchResults, local)
				break
			}
		}
	}

	return nil
}

// LoadUserBRef allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (matchResultL) LoadUserBRef(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMatchResult interface{}, mods queries.Applicator) error {
	var slice []*MatchResult
	var object *MatchResult

	if singular {
		var ok bool
		object, ok = maybeMatchResult.(*MatchResult)
		if !ok {
			object = new(MatchResult)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatchResult)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatchResult))
			}
		}
	} else {
		s, ok := maybeMatchResult.(*[]*MatchResult)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatchResult)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatchResult))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchResultR{}
		}
		args[object.ReceiverUserRefID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchResultR{}
			}

			args[obj.ReceiverUserRefID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.UserBRef = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.UserBRefMatchResults = append(foreign.R.UserBRefMatchResults, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ReceiverUserRefID == foreign.ID {
				local.R.UserBRef = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.UserBRefMatchResults = append(foreign.R.UserBRefMatchResults, local)
				break
			}
		}
	}

	return nil
}

// LoadMatchResultRefDateInstances allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (matchResultL) LoadMatchResultRefDateInstances(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMatchResult interface{}, mods queries.Applicator) error {
	var slice []*MatchResult
	var object *MatchResult

	if singular {
		var ok bool
		object, ok = maybeMatchResult.(*MatchResult)
		if !ok {
			object = new(MatchResult)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatchResult)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatchResult))
			}
		}
	} else {
		s, ok := maybeMatchResult.(*[]*MatchResult)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatchResult)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatchResult))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchResultR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchResultR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`date_instance`),
		qm.WhereIn(`date_instance.match_result_ref_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load date_instance")
	}

	var resultSlice []*DateInstance
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice date_instance")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on date_instance")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for date_instance")
	}

	if len(dateInstanceAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MatchResultRefDateInstances = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dateInstanceR{}
			}
			foreign.R.MatchResultRef = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.MatchResultRefID {
				local.R.MatchResultRefDateInstances = append(local.R.MatchResultRefDateInstances, foreign)
				if foreign.R == nil {
					foreign.R = &dateInstanceR{}
				}
				foreign.R.MatchResultRef = local
				break
			}
		}
	}

	return nil
}

// LoadMatchChatMessages allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (matchResultL) LoadMatchChatMessages(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMatchResult interface{}, mods queries.Applicator) error {
	var slice []*MatchResult
	var object *MatchResult

	if singular {
		var ok bool
		object, ok = maybeMatchResult.(*MatchResult)
		if !ok {
			object = new(MatchResult)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatchResult)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatchResult))
			}
		}
	} else {
		s, ok := maybeMatchResult.(*[]*MatchResult)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatchResult)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatchResult))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchResultR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchResultR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`match_chat_message`),
		qm.WhereIn(`match_chat_message.match_result_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load match_chat_message")
	}

	var resultSlice []*MatchChatMessage
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice match_chat_message")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on match_chat_message")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for match_chat_message")
	}

	if len(matchChatMessageAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MatchChatMessages = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &matchChatMessageR{}
			}
			foreign.R.MatchResult = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.MatchResultID {
				local.R.MatchChatMessages = append(local.R.MatchChatMessages, foreign)
				if foreign.R == nil {
					foreign.R = &matchChatMessageR{}
				}
				foreign.R.MatchResult = local
				break
			}
		}
	}

	return nil
}

// SetCurrentDateInstance of the matchResult to the related item.
// Sets o.R.CurrentDateInstance to related.
// Adds o to related.R.CurrentDateInstanceMatchResults.
func (o *MatchResult) SetCurrentDateInstance(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DateInstance) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"match_result\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"current_date_instance_id"}),
		strmangle.WhereClause("\"", "\"", 2, matchResultPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CurrentDateInstanceID, related.ID)
	if o.R == nil {
		o.R = &matchResultR{
			CurrentDateInstance: related,
		}
	} else {
		o.R.CurrentDateInstance = related
	}

	if related.R == nil {
		related.R = &dateInstanceR{
			CurrentDateInstanceMatchResults: MatchResultSlice{o},
		}
	} else {
		related.R.CurrentDateInstanceMatchResults = append(related.R.CurrentDateInstanceMatchResults, o)
	}

	return nil
}

// RemoveCurrentDateInstance relationship.
// Sets o.R.CurrentDateInstance to nil.
// Removes o from all passed in related items' relationships struct.
func (o *MatchResult) RemoveCurrentDateInstance(ctx context.Context, exec boil.ContextExecutor, related *DateInstance) error {
	var err error

	queries.SetScanner(&o.CurrentDateInstanceID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("current_date_instance_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.CurrentDateInstance = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.CurrentDateInstanceMatchResults {
		if queries.Equal(o.CurrentDateInstanceID, ri.CurrentDateInstanceID) {
			continue
		}

		ln := len(related.R.CurrentDateInstanceMatchResults)
		if ln > 1 && i < ln-1 {
			related.R.CurrentDateInstanceMatchResults[i] = related.R.CurrentDateInstanceMatchResults[ln-1]
		}
		related.R.CurrentDateInstanceMatchResults = related.R.CurrentDateInstanceMatchResults[:ln-1]
		break
	}
	return nil
}

// SetInitiatorUserRef of the matchResult to the related item.
// Sets o.R.InitiatorUserRef to related.
// Adds o to related.R.InitiatorUserRefMatchResults.
func (o *MatchResult) SetInitiatorUserRef(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"match_result\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"initiator_user_ref_id"}),
		strmangle.WhereClause("\"", "\"", 2, matchResultPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.InitiatorUserRefID = related.ID
	if o.R == nil {
		o.R = &matchResultR{
			InitiatorUserRef: related,
		}
	} else {
		o.R.InitiatorUserRef = related
	}

	if related.R == nil {
		related.R = &userR{
			InitiatorUserRefMatchResults: MatchResultSlice{o},
		}
	} else {
		related.R.InitiatorUserRefMatchResults = append(related.R.InitiatorUserRefMatchResults, o)
	}

	return nil
}

// SetMatchSetRef of the matchResult to the related item.
// Sets o.R.MatchSetRef to related.
// Adds o to related.R.MatchSetRefMatchResults.
func (o *MatchResult) SetMatchSetRef(ctx context.Context, exec boil.ContextExecutor, insert bool, related *MatchSet) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"match_result\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"match_set_ref_id"}),
		strmangle.WhereClause("\"", "\"", 2, matchResultPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.MatchSetRefID = related.ID
	if o.R == nil {
		o.R = &matchResultR{
			MatchSetRef: related,
		}
	} else {
		o.R.MatchSetRef = related
	}

	if related.R == nil {
		related.R = &matchSetR{
			MatchSetRefMatchResults: MatchResultSlice{o},
		}
	} else {
		related.R.MatchSetRefMatchResults = append(related.R.MatchSetRefMatchResults, o)
	}

	return nil
}

// SetReceiverUserRef of the matchResult to the related item.
// Sets o.R.ReceiverUserRef to related.
// Adds o to related.R.ReceiverUserRefMatchResults.
func (o *MatchResult) SetReceiverUserRef(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"match_result\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"receiver_user_ref_id"}),
		strmangle.WhereClause("\"", "\"", 2, matchResultPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ReceiverUserRefID = related.ID
	if o.R == nil {
		o.R = &matchResultR{
			ReceiverUserRef: related,
		}
	} else {
		o.R.ReceiverUserRef = related
	}

	if related.R == nil {
		related.R = &userR{
			ReceiverUserRefMatchResults: MatchResultSlice{o},
		}
	} else {
		related.R.ReceiverUserRefMatchResults = append(related.R.ReceiverUserRefMatchResults, o)
	}

	return nil
}

// SetUserARef of the matchResult to the related item.
// Sets o.R.UserARef to related.
// Adds o to related.R.UserARefMatchResults.
func (o *MatchResult) SetUserARef(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"match_result\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"initiator_user_ref_id"}),
		strmangle.WhereClause("\"", "\"", 2, matchResultPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.InitiatorUserRefID = related.ID
	if o.R == nil {
		o.R = &matchResultR{
			UserARef: related,
		}
	} else {
		o.R.UserARef = related
	}

	if related.R == nil {
		related.R = &userR{
			UserARefMatchResults: MatchResultSlice{o},
		}
	} else {
		related.R.UserARefMatchResults = append(related.R.UserARefMatchResults, o)
	}

	return nil
}

// SetUserBRef of the matchResult to the related item.
// Sets o.R.UserBRef to related.
// Adds o to related.R.UserBRefMatchResults.
func (o *MatchResult) SetUserBRef(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"match_result\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"receiver_user_ref_id"}),
		strmangle.WhereClause("\"", "\"", 2, matchResultPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ReceiverUserRefID = related.ID
	if o.R == nil {
		o.R = &matchResultR{
			UserBRef: related,
		}
	} else {
		o.R.UserBRef = related
	}

	if related.R == nil {
		related.R = &userR{
			UserBRefMatchResults: MatchResultSlice{o},
		}
	} else {
		related.R.UserBRefMatchResults = append(related.R.UserBRefMatchResults, o)
	}

	return nil
}

// AddMatchResultRefDateInstances adds the given related objects to the existing relationships
// of the match_result, optionally inserting them as new records.
// Appends related to o.R.MatchResultRefDateInstances.
// Sets related.R.MatchResultRef appropriately.
func (o *MatchResult) AddMatchResultRefDateInstances(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DateInstance) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.MatchResultRefID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"date_instance\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"match_result_ref_id"}),
				strmangle.WhereClause("\"", "\"", 2, dateInstancePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.MatchResultRefID = o.ID
		}
	}

	if o.R == nil {
		o.R = &matchResultR{
			MatchResultRefDateInstances: related,
		}
	} else {
		o.R.MatchResultRefDateInstances = append(o.R.MatchResultRefDateInstances, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dateInstanceR{
				MatchResultRef: o,
			}
		} else {
			rel.R.MatchResultRef = o
		}
	}
	return nil
}

// AddMatchChatMessages adds the given related objects to the existing relationships
// of the match_result, optionally inserting them as new records.
// Appends related to o.R.MatchChatMessages.
// Sets related.R.MatchResult appropriately.
func (o *MatchResult) AddMatchChatMessages(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MatchChatMessage) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.MatchResultID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"match_chat_message\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"match_result_id"}),
				strmangle.WhereClause("\"", "\"", 2, matchChatMessagePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.MatchResultID = o.ID
		}
	}

	if o.R == nil {
		o.R = &matchResultR{
			MatchChatMessages: related,
		}
	} else {
		o.R.MatchChatMessages = append(o.R.MatchChatMessages, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &matchChatMessageR{
				MatchResult: o,
			}
		} else {
			rel.R.MatchResult = o
		}
	}
	return nil
}

// MatchResults retrieves all the records using an executor.
func MatchResults(mods ...qm.QueryMod) matchResultQuery {
	mods = append(mods, qm.From("\"match_result\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"match_result\".*"})
	}

	return matchResultQuery{q}
}

// FindMatchResult retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindMatchResult(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*MatchResult, error) {
	matchResultObj := &MatchResult{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"match_result\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, matchResultObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "pgmodel: unable to select from match_result")
	}

	if err = matchResultObj.doAfterSelectHooks(ctx, exec); err != nil {
		return matchResultObj, err
	}

	return matchResultObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *MatchResult) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("pgmodel: no match_result provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(matchResultColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	matchResultInsertCacheMut.RLock()
	cache, cached := matchResultInsertCache[key]
	matchResultInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			matchResultAllColumns,
			matchResultColumnsWithDefault,
			matchResultColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(matchResultType, matchResultMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(matchResultType, matchResultMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"match_result\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"match_result\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "pgmodel: unable to insert into match_result")
	}

	if !cached {
		matchResultInsertCacheMut.Lock()
		matchResultInsertCache[key] = cache
		matchResultInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the MatchResult.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *MatchResult) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	matchResultUpdateCacheMut.RLock()
	cache, cached := matchResultUpdateCache[key]
	matchResultUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			matchResultAllColumns,
			matchResultPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("pgmodel: unable to update match_result, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"match_result\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, matchResultPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(matchResultType, matchResultMapping, append(wl, matchResultPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to update match_result row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: failed to get rows affected by update for match_result")
	}

	if !cached {
		matchResultUpdateCacheMut.Lock()
		matchResultUpdateCache[key] = cache
		matchResultUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q matchResultQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to update all for match_result")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to retrieve rows affected for match_result")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o MatchResultSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("pgmodel: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), matchResultPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"match_result\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, matchResultPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to update all in matchResult slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to retrieve rows affected all in update all matchResult")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *MatchResult) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("pgmodel: no match_result provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(matchResultColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	matchResultUpsertCacheMut.RLock()
	cache, cached := matchResultUpsertCache[key]
	matchResultUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			matchResultAllColumns,
			matchResultColumnsWithDefault,
			matchResultColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			matchResultAllColumns,
			matchResultPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("pgmodel: unable to upsert match_result, could not build update column list")
		}

		ret := strmangle.SetComplement(matchResultAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(matchResultPrimaryKeyColumns) == 0 {
				return errors.New("pgmodel: unable to upsert match_result, could not build conflict column list")
			}

			conflict = make([]string, len(matchResultPrimaryKeyColumns))
			copy(conflict, matchResultPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"match_result\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(matchResultType, matchResultMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(matchResultType, matchResultMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "pgmodel: unable to upsert match_result")
	}

	if !cached {
		matchResultUpsertCacheMut.Lock()
		matchResultUpsertCache[key] = cache
		matchResultUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single MatchResult record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *MatchResult) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("pgmodel: no MatchResult provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), matchResultPrimaryKeyMapping)
	sql := "DELETE FROM \"match_result\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to delete from match_result")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: failed to get rows affected by delete for match_result")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q matchResultQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("pgmodel: no matchResultQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to delete all from match_result")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: failed to get rows affected by deleteall for match_result")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o MatchResultSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(matchResultBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), matchResultPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"match_result\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, matchResultPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: unable to delete all from matchResult slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "pgmodel: failed to get rows affected by deleteall for match_result")
	}

	if len(matchResultAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *MatchResult) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindMatchResult(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *MatchResultSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := MatchResultSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), matchResultPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"match_result\".* FROM \"match_result\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, matchResultPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "pgmodel: unable to reload all in MatchResultSlice")
	}

	*o = slice

	return nil
}

// MatchResultExists checks if the MatchResult row exists.
func MatchResultExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"match_result\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "pgmodel: unable to check if match_result exists")
	}

	return exists, nil
}

// Exists checks if the MatchResult row exists.
func (o *MatchResult) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return MatchResultExists(ctx, exec, o.ID)
}
